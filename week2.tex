\chapter{汇编语言}
    \begin{summary}
        \begin{compactitem}
            \item 知道 x86-64 中指令、程序计数器、寄存器、条件码、内存等概念，记住重要的寄存器名称、含义和使用规范，清楚掌握数据传送指令和操作数的正确用法。
            \item 掌握条件分支、条件传送、各种循环、跳转表的翻译方式，能熟练地在汇编语言中识别控制流结构，快速完成机器码、汇编语言、C 代码的相互转换。
            \item 理解 x86-64 系统栈空间的分布和管理方式，知道过程调用中的重要寄存器和相关保存指令，会复述过程调用的整个过程并绘制栈空间的变化情况。
            \item 知道结构体、联合体在内存中的存储情况，掌握用对齐规则访问结构体和联合体，以及计算其实际大小的方法。会处理复杂的指针和函数指针问题。
        \end{compactitem}
    \end{summary}

    \begin{problems}
        \pro 判断下列 x86-64 ATT 操作数格式是否合法。
            \qn \verb|8(%rax, , 2)|
            \qn \verb|$30(%rax, %rax, 2)|
            \qn \verb|0x30|
            \qn \verb|13(, %rdi, 4)|
            \qn \verb|(%rsi, %rdi, 6)|
            \qn \verb|%ecx|
            \qn \verb|(%ecx)|
            \qn \verb|(%rbp, %rsp)|
        \pro 假设 \verb|%rax|、\verb|%rbx| 的初始值都是 0。根据下列一段汇编代码，写出每执行一步后两个寄存器的值。
        \begin{minted}[frame=single, fontsize=\small]{gas}
    movabsq   $0x0123456789ABCDEF, %rax
    movw      %ax, %bx
    movswq    %bx, %rbx
    movl      %ebx, %eax
    movabsq   $0x123456789ABCDEF, %rax
    cltq
        \end{minted}
        \pro 下列操作不等价的是：
        \begin{choices}
            \item \verb|movzbq| 和 \verb|movzbl|
            \item \verb|movzwq| 和 \verb|movzwl|
            \item \verb|movl| 和 \verb|movslq|
            \item \verb|movslq %eax, %rax| 和 \verb|cltq|
        \end{choices}
        \pro 判断下列 x86-64 ATT 数据传送指令是否合法。
            \qn \verb|movl $0x400010, $0x800010|
            \qn \verb|movl $0x400010, 0x800010|
            \qn \verb|movl 0x400010, 0x800010|
            \qn \verb|movq $-4, (%rsp)|
            \qn \verb|movq $0x123456789AB, %rax|
            \qn \verb|movabsq $0x123456789AB, %rdi|
            \qn \verb|movabsq $0x123456789AB, 16(%rcx)|
            \qn \verb|movq 8(%rsp), %rip|
        \pro 在 32 位机器中有如下定义 \texttt{int array[10] = \{0, 1, 2, 3, 4, 5, 6, 7, 8, 9\};}。
        
        某一时刻，\verb|%ecx| 存着第一个元素的地址，\verb|%ebx| 值为 3，那么下列操作中，哪一个将 \verb|array[3]| 移入了 \verb|%eax|？
        \begin{choices}
            \item \verb|leal 12(%ecx), %eax|
            \item \verb|leal (%ecx, %ebx, 4), %eax|
            \item \verb|movl (%ecx, %ebx, 4), %eax|
            \item \verb|movl 8(%ecx, %ebx, 2), %eax|
        \end{choices}
        \pro 下面的汇编代码对应一个 C 函数，其原型为 \verb|long func(long a, long b);|。将其翻译为 C 代码。
        \begin{minted}[frame=single, fontsize=\small]{gas}
    // a in %rdi, b in %rsi
    func:
        movq   %rdi, %rax
        salq   $4, %rax
        subq   %rdi, %rax
        movq   %rax, %rdi
        leaq   0(, %rsi, 8), %rax
        subq   %rsi, %rax
        addq   %rdi, %rax
        ret
        \end{minted}
        \pro 指令 \verb|setg %al| 会让寄存器 \verb|%al| 得到：
        \begin{choices}
            \item \verb+~(SF ^ OF) & ~ZF+
            \item \verb+~(SF | OF) & ~ZF+
            \item \verb+~(SF | OF)+
            \item \verb+~(SF ^ OF)+
        \end{choices}
        \pro 下面的汇编代码对应一个 C 函数，其原型为 \verb|long func(long a, long b);|。将其翻译为 C 代码。
        \begin{minted}[frame=single, fontsize=\small]{gas}
    // a in %rdi, b in %rsi
    func: 
        movl    $1, %eax
        jmp     .L2
    .L4: 
        testb   $1, %sil
        je      .L3
        imulq   %rdi, %rax
    .L3: 
        sarq    %rsi
        imulq   %rdi, %rdi
    .L2: 
        testq   %rsi, %rsi
        jg      .L4
        rep ret 
        \end{minted}
        \pro 对于下列四个函数，假设 gcc 开了编译优化，判断 gcc 是否会将其编译为条件传送。
        \qn
        \begin{minted}[frame=single, fontsize=\small]{c}
    long f1(long a, long b) { return (++a > --b) ? a : b; }
        \end{minted}
        \qn
        \begin{minted}[frame=single, fontsize=\small]{c}
    long f2(long a, long b) { return (*a > *b) ? --(*a) : (*b)--; }
        \end{minted}
        \qn
        \begin{minted}[frame=single, fontsize=\small]{c}
    long f3(long a, long b) { return a ? *a : (b ? *b : 0); }
        \end{minted}
        \qn
        \begin{minted}[frame=single, fontsize=\small]{c}
    long f4(long a, long b) { return (a > b) ? a++ : ++b; }
        \end{minted}
        \pro 根据下面的汇编指令补充机器码中缺失的字节。
        \begin{table}[H]
            \centering
            \begin{tabular}{|c|c|}
                \hline
                机器码 & 汇编指令 \\ \hline
                \tt
                \begin{tabular}{l}
                    loop: \\
                    4004d0: 48 89 f8 \\
                    4004d3: eb \verb|_____| \\
                    4004d5: 48 d1 f8 \\
                    4004d8: 48 85 c0 \\
                    4004db: 7f \verb|_____| \\
                    4004dd: f3 c3 
                \end{tabular} &
                \begin{tabular}{l}
                    \\
                    \verb|mov   %rdi, %rax| \\
                    \verb|jmp   4004d8 <loop+0x8>| \\
                    \verb|sar   %rax| \\
                    \verb|test  %rax, %rax| \\
                    \verb|jg    4004d5 <loop+0x5>| \\
                    \verb|repz retq|
                \end{tabular}
                \\ \hline
            \end{tabular}
        \end{table}
        \pro 使用 GDB 查看某个可执行文件，发现其一段内存为：
        \begin{minted}[frame=single, fontsize=\small]{text}
    0x400598: 0x0000000000400488 0x0000000000400488
    0x4005a8: 0x000000000040048b 0x0000000000400493
    0x4005b8: 0x000000000040049a 0x0000000000400482
    0x4005c8: 0x000000000040049a 0x0000000000400498
        \end{minted}
        根据以下汇编代码，
        \begin{minted}[frame=single, fontsize=\small]{gas}
    0x400474: cmp   $0x7, %edi
    0x400477: ja    0x40049a
    0x400479: mov   %edi, %edi
    0x40047b: jmpq  *0x400598(, %rdi, 8)
    0x400482: mov   $0x15213, %eax
    0x400487: retq
    0x400488: sub   $0x5, %edx
    0x40048b: lea   0x0(, %rdx, 4), %eax
    0x400492: retq
    0x400493: mov   $0x2, %edx
    0x400498: and   %edx, %esi
    0x40049a: lea   0x4(%rsi), %eax
    0x40049d: retq             
        \end{minted}
        补全主函数的 C 代码。
        \begin{minted}[frame=single, fontsize=\small]{c}
    // a in %rdi, b in %rsi, c in %rdx
    int main(int a, int b, int c) {
        int res = 4;
        switch (a) {
            case 0:
            case 1:
                __________;
            case ___:
                res = __________;
                break;
            case ___:
                res = __________;
                break;
            case 3:
                __________;
            case 7:
                __________;
            default:
                __________;
        }
        return res;
    }
        \end{minted}
    \end{problems}

\chapter{汇编语言{---}往年考题}
    \begin{problems}
        \proy{2018} 在 x86-64 下，以下哪个选项的说法是错误的？
        \begin{choices}
            \item \verb|movl| 指令以寄存器作为目的时，会将该寄存器的高位 4 字节设置为 0
            \item \verb|cltq| 指令的作用是将 \verb|%eax| 符号扩展到 \verb|%rax|
            \item \verb|movabsq| 指令只能以寄存器作为目的
            \item \verb|movswq| 指令的作用是将零扩展的字传送到四字节目的
        \end{choices}
        \proy{2018} 下列关于程序控制结构的机器代码实现的说法中，正确的是：
        \begin{choices}
            \item 使用条件跳转语句实现的程序片段比使用条件赋值语句实现的同一程序片段的运行效率高
            \item 使用条件跳转语句实现的程序片段与使用条件赋值语句实现的同一程序片段虽然效率可能不同，但在 C 语言的层面上看总是有着相同的行为
            \item 一些 \verb|switch| 语句不会被 gcc 用跳转表的方式实现
            \item 以上说法都不正确
        \end{choices}
        \proy{2017} 下列关于条件码的叙述中，不正确的是：
        \begin{choices}
            \item 所有算术指令都会改变条件码
            \item 所有比较指令都会改变条件码
            \item 所有与数据传送有关的指令都会改变条件码
            \item 条件码一般不会直接读取，但可以直接修改
        \end{choices}
        \proy{2017} 在下列的 x86-64 汇编代码中，错误的是：
        \begin{choices}
            \item \verb|movq %rax, (%rsp)|
            \item \verb|movl $0xFF, (%ebx)|
            \item \verb|movsbl (%rdi), %eax|
            \item \verb|leaq (%rdx, 1), %rdx|
        \end{choices}
        \proy{2017} 在下列关于条件传送的说法中，正确的是：
        \begin{choices}
            \item 条件传送可以用来传送字节、字、双字和四字的数据
            \item C语言中的“\verb|?:|”条件表达式都可以编译成条件传送
            \item 使用条件传送总可以提高代码的执行效率
            \item 条件传送指令不需要用后缀(例如 \verb|b, w, l, q|)来表明操作数的长度
        \end{choices}
        \proy{2017} 在下列指令中，其执行会影响条件码中的 CF 位的是：
        \begin{choices}
            \item \verb|jmp NEXT|
            \item \verb|jc NEXT|
            \item \verb|inc %bx|
            \item \verb|shl $1, %ax|
        \end{choices}
        \proy{2016} 下列关于比较指令 \verb|cmp| 说法中，正确的是：
        \begin{choices}
            \item 专用于有符号数比较
            \item 专用于无符号数比较
            \item 专用于串比较
            \item 不区分比较的对象是有符号数还是无符号数
        \end{choices}
        \proy{2016} 在如下代码段的跳转指令中，目的地址是：
        \begin{minted}[frame=single, fontsize=\small]{gas}
    400020: 74 F0 je   ________
    400022: 5d    pop  %rbp
        \end{minted}
        \begin{choices}
            \item \texttt{400010}
            \item \texttt{400012}
            \item \texttt{400110}
            \item \texttt{400112}
        \end{choices}
        \proy{2016} 对于如下的 C 语言中的条件转移指令，它所对应的汇编代码中至少包含几条条件转移指令：\verb+if (a > 0 && a != 1 || a < 0 && a != -1) b = a;+？
        \begin{choices}
            \item 2 条
            \item 3 条
            \item 4 条
            \item 5 条
        \end{choices}
        \proy{2016} 将 \verb|%ax| 清零，下列指令不能实现该效果的是：
        \begin{choices}
            \item \verb|sub %ax, %ax|
            \item \verb|xor %ax, %ax|
            \item \verb|test %ax, %ax|
            \item \verb|and $0, %ax|
        \end{choices}
        \proy{2016} 在如下 \verb|switch| 语句翻译得到的跳转表中，哪些标号没有出现在分支中？
        \begin{minted}[frame=single, fontsize=\small]{gas}
    addq    $1, %rdi
    cmpq    $8, %rdi
    ja      .L2
    jmp     *.L4(, %rdi, 8)
    .L4:
        .quad .L9
        .quad .L5
        .quad .L6
        .quad. L7
        .quad .L2
        .quad .L7
        .quad .L8
        .quad .L2
        .quad .L5
        \end{minted}
        \begin{choices}
            \item 3, 6
            \item $-1$, 4
            \item 0, 7
            \item 2, 4
        \end{choices}
        \proy{2016} 已知短整型数组 \verb|S| 的起始地址和下标 \verb|i| 分别存放在寄存器 \verb|%rdx| 和\verb|%rcx|，将 \verb|&S[i]| 存放在寄存器\verb|%rax| 中所对应的汇编代码是：
        \begin{choices}
            \item \verb|leaq (%rdx, %rcx, 1), %rax|
            \item \verb|movw (%rdx, %rcx, 2), %rax|
            \item \verb|leaq (%rdx, %rcx, 2), %rax|
            \item \verb|movw (%rdx, %rcx, 1), %rax|
        \end{choices}
        \proy{2015} 下列寻址模式中，正确的是：
        \begin{choices}
            \item \verb|(%eax, , 4)|
            \item \verb|(%eax, %esp, 3)|
            \item \verb|123|
            \item \verb|$1(%ebx, %ebp, 1)|
        \end{choices}
        \proy{2015} 假设某条 C 语言 \verb|switch| 语句编译后产生了如下的汇编代码及跳转表：
        \begin{minted}[frame=single, fontsize=\small]{gas}
    movl   8(%ebp), %eax
    subl   $48, %eax
    cmpl   $8, %eax
    ja     .L2
    jmp    *.L7(, %eax, 4)
    .L7:
        .long .L3
        .long .L2
        .long .L2
        .long .L5
        .long .L4
        .long .L5
        .long .L6
        .long .L2
        .long .L3
        \end{minted}
        在源程序中，下面的哪些标号出现过？
        \begin{choices}
            \item 2, 7
            \item 1
            \item 3
            \item 5
        \end{choices}
        \proy{2015, 2014} 下列的指令组中，哪一组指令只改变条件码，而不改变寄存器的值？
        \begin{choices}
            \item \verb|CMP, SUB|
            \item \verb|TEST, AND|
            \item \verb|CMP, TEST|
            \item \verb|LEAL, CMP|
        \end{choices}
        \proy{2014} 简单的 \verb|switch| 语句常采用跳转表的方式实现，在 x86-64 系统中，下述最有可能是正确的 \verb|switch| 分支跳转汇编指令的是哪个？
        \begin{choices}
            \item \verb|jmp .L3(, %eax, 4)|
            \item \verb|jmp .L3(, %eax, 8)|
            \item \verb|jmp *.L3(, %eax, 4)|
            \item \verb|jmp *.L3(, %eax, 8)|
        \end{choices}
    \end{problems}