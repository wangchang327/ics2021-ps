\chapter{汇编语言}
    \begin{summary}
        \begin{compactitem}
            \item 知道 x86-64 中指令、程序计数器、寄存器、条件码、内存等概念，记住重要的寄存器名称、含义和使用规范，清楚掌握数据传送指令和操作数的正确用法。
            \item 掌握条件分支、条件传送、各种循环、跳转表的翻译方式，能熟练地在汇编语言中识别控制流结构，快速完成机器码、汇编语言、C 代码的相互转换。
            \item 理解 x86-64 系统栈空间的分布和管理方式，知道过程调用中的重要寄存器和相关保存指令，会复述过程调用的整个过程并绘制栈空间的变化情况。
            \item 知道结构体、联合体在内存中的存储情况，掌握用对齐规则访问结构体和联合体，以及计算其实际大小的方法。会处理复杂的指针和函数指针问题。
        \end{compactitem}
    \end{summary}

    \begin{problems}
        \pro 判断下列 x86-64 ATT 操作数格式是否合法。
            \qn \verb|8(%rax, , 2)|
            \qn \verb|$30(%rax, %rax, 2)|
            \qn \verb|0x30|
            \qn \verb|13(, %rdi, 4)|
            \qn \verb|(%rsi, %rdi, 6)|
            \qn \verb|%ecx|
            \qn \verb|(%ecx)|
            \qn \verb|(%rbp, %rsp)|
        \sol 1 不正确；2 不正确，\verb|$| 只用来表示立即数；3 正确，是内存地址 \verb|0x30|；4 正确；5 不正确，缩放比例只能是 1、2、4、8；6 正确；7 不正确，x86-64 不允许将除了 64 位寄存器以外的寄存器作为寻址模式基地址；8不正确，\verb|%rsp|不能作为操作数！
        \pro 假设 \verb|%rax|、\verb|%rbx| 的初始值都是 0。根据下列一段汇编代码，写出每执行一步后两个寄存器的值。
        \begin{minted}[frame=single, fontsize=\small]{text}
    movabsq   $0x0123456789ABCDEF, %rax
    movw      %ax, %bx
    movswq    %bx, %rbx
    movl      %ebx, %eax
    movabsq   $0x0123456789ABCDEF, %rax
    cltq
        \end{minted}
        \sol 注意 \verb|movl| 会清零高 32 位。如果 \verb|movabsq| 的立即数是负数，主要要取绝对值（本题中不需要）。答案为：
        \begin{compactenum}
            \item \ \verb|0x0123456789ABCDEF, 0x0000000000000000|
            \item \ \verb|0x0123456789ABCDEF, 0x000000000000CDEF|
            \item \ \verb|0x0123456789ABCDEF, 0xFFFFFFFFFFFFCDEF|
            \item \ \verb|0x00000000FFFFCDEF, 0xFFFFFFFFFFFFCDEF|
            \item \ \verb|0x0123456789ABCDEF, 0xFFFFFFFFFFFFCDEF|
            \item \ \verb|0xFFFFFFFF89ABCDEF, 0xFFFFFFFFFFFFCDEF|
        \end{compactenum}
        \pro 下列操作不等价的是：
        \begin{choices}
            \item \verb|movzbq| 和 \verb|movzbl|
            \item \verb|movzwq| 和 \verb|movzwl|
            \item \verb|movl| 和 \verb|movslq|
            \item \verb|movslq %eax, %rax| 和 \verb|cltq|
        \end{choices}
        \sol C。A、B 中，\verb|movzbl/movzwl| 都生成了四字节，把高位设为0。D 中 \verb|cltq| 是对 \verb|%eax|的符号拓展。而 C 中 \verb|movl| 和 \verb|movzlq| 等价。
        \pro 判断下列 x86-64 ATT 数据传送指令是否合法。
            \qn \verb|movl $0x400010, $0x800010|
            \qn \verb|movl $0x400010, 0x800010|
            \qn \verb|movl 0x400010, 0x800010|
            \qn \verb|movq $-4, (%rsp)|
            \qn \verb|movq $0x123456789AB, %rax|
            \qn \verb|movabsq $0x123456789AB, %rdi|
            \qn \verb|movabsq $0x123456789AB, 16(%rcx)|
            \qn \verb|movq 8(%rsp), %rip|
        \sol 1 不正确，目的不能是立即数；2 正确；3 不正确，两个操作数不能同时是内存地址；4 正确；5 不正确，要用 \verb|movabsq|；6 正确；7 不正确，\verb|movabsq| 的目标地址必须是整数寄存器；8 不正确，不能用 \verb|mov| 向 \verb|%rip| 中传入数据，否则读程序计数器产生破坏。
        \pro 在 32 位机器中有如下定义 \texttt{int array[10] = \{0, 1, 2, 3, 4, 5, 6, 7, 8, 9\};}。
        
        某一时刻，\verb|%ecx| 存着第一个元素的地址，\verb|%ebx| 值为 3，那么下列操作中，哪一个将 \verb|array[3]| 移入了 \verb|%eax|？
        \begin{choices}
            \item \verb|leal 12(%ecx), %eax|
            \item \verb|leal (%ecx, %ebx, 4), %eax|
            \item \verb|movl (%ecx, %ebx, 4), %eax|
            \item \verb|movl 8(%ecx, %ebx, 2), %eax|
        \end{choices}
        \sol C，注意前两个选项只是计算了地址，而 \verb|int| 每个元素 4 字节，D 错误。
        \pro 下面的汇编代码对应一个 C 函数，其原型为 \verb|long func(long a, long b);|。将其翻译为 C 代码。
        \begin{minted}[frame=single, fontsize=\small]{text}
    // a in %rdi, b in %rsi
    func:
        movq   %rdi, %rax
        salq   $4, %rax
        subq   %rdi, %rax
        movq   %rax, %rdi
        leaq   0(, %rsi, 8), %rax
        subq   %rsi, %rax
        addq   %rdi, %rax
        ret
        \end{minted}
        \sol 如下所示:
        \begin{minted}[frame=single, fontsize=\small]{c}
    long func(long a, long b) {
        return a * 15 + b * 7;
    }
        \end{minted}
        \pro 指令 \verb|setg %al| 会让寄存器 \verb|%al| 得到：
        \begin{choices}
            \item \verb+~(SF ^ OF) & ~ZF+
            \item \verb+~(SF | OF) & ~ZF+
            \item \verb+~(SF | OF)+
            \item \verb+~(SF ^ OF)+
        \end{choices}
        \sol A。如果 \verb|a > b|，那么 \verb|a – b| 或者为正，或者发生上溢变负；同时 \verb|a| 不等于 \verb|b|。
        \pro 下面的汇编代码对应一个 C 函数，其原型为 \verb|long func(long a, long b);|。将其翻译为 C 代码。
        \begin{minted}[frame=single, fontsize=\small]{text}
    // a in %rdi, b in %rsi
    func: 
        movl    $1, %eax
        jmp     .L2
    .L4: 
        testb   $1, %sil
        je      .L3
        imulq   %rdi, %rax
    .L3: 
        sarq    %rsi
        imulq   %rdi, %rdi
    .L2: 
        testq   %rsi, %rsi
        jg      .L4
        rep ret 
        \end{minted}
        \sol 如下所示（快速幂）：
        \begin{minted}[frame=single, fontsize=\small]{c}
    long func(long a, long b) {
        long ans = 1;
        while (b > 0) {
            if (b & 1)
                ans = ans * a;
            b = b >> 1;
            a = a * a;
        }
        return ans;
    }
        \end{minted}
        \pro 对于下列四个函数，假设 gcc 开了编译优化，判断 gcc 是否会将其编译为条件传送。
        \qn
        \begin{minted}[frame=single, fontsize=\small]{c}
    long f1(long a, long b) { return (++a > --b) ? a : b; }
        \end{minted}
        \qn
        \begin{minted}[frame=single, fontsize=\small]{c}
    long f2(long a, long b) { return (*a > *b) ? --(*a) : (*b)--; }
        \end{minted}
        \qn
        \begin{minted}[frame=single, fontsize=\small]{c}
    long f3(long a, long b) { return a ? *a : (b ? *b : 0); }
        \end{minted}
        \qn
        \begin{minted}[frame=single, fontsize=\small]{c}
    long f4(long a, long b) { return (a > b) ? a++ : ++b; }
        \end{minted}
        \sol 1、4 会被编译成条件传送。1 由于比较前计算出的 \verb|a| 与 \verb|b| 就是传送的目标，因此会被编译成条件传送；2 由于比较结果会导致 \verb|a| 与 \verb|b| 指向的元素发生不同的改变，因此会被编译成条件跳转；3 由于指针 \verb|a| 可能无效，因此会被编译为条件跳转；4 会被编译成条件传送，因为 \verb|a| 和 \verb|b| 都是局部变量，返回的时候对 \verb|a| 和 \verb|b| 的操作都是无影响的。
        \pro 根据下面的汇编指令补充机器码中缺失的字节。
        \begin{table}[H]
            \centering
            \begin{tabular}{|c|c|}
                \hline
                机器码 & 汇编指令 \\ \hline
                \tt
                \begin{tabular}{l}
                    loop: \\
                    4004d0: 48 89 f8 \\
                    4004d3: eb \verb|_____| \\
                    4004d5: 48 d1 f8 \\
                    4004d8: 48 85 c0 \\
                    4004db: 7f \verb|_____| \\
                    4004dd: f3 c3 
                \end{tabular} &
                \begin{tabular}{l}
                    \\
                    \verb|mov   %rdi, %rax| \\
                    \verb|jmp   4004d8 <loop+0x8>| \\
                    \verb|sar   %rax| \\
                    \verb|test  %rax, %rax| \\
                    \verb|jg    4004d5 <loop+0x5>| \\
                    \verb|repz retq|
                \end{tabular}
                \\ \hline
            \end{tabular}
        \end{table}
        \sol \verb|03; f8|。第五行跳转位置为 \verb|0xf8(-8) + 0x4004dd = 0x4004d5|，注意进行跳转之前，PC 指向该指令的下一条指令。
        \pro 使用 GDB 查看某个可执行文件，发现其一段内存为：
        \begin{minted}[frame=single, fontsize=\small]{text}
    0x400598: 0x0000000000400488 0x0000000000400488
    0x4005a8: 0x000000000040048b 0x0000000000400493
    0x4005b8: 0x000000000040049a 0x0000000000400482
    0x4005c8: 0x000000000040049a 0x0000000000400498
        \end{minted}
        根据以下汇编代码，
        \begin{minted}[frame=single, fontsize=\small]{text}
    0x400474: cmp   $0x7, %edi
    0x400477: ja    0x40049a
    0x400479: mov   %edi, %edi
    0x40047b: jmpq  *0x400598(, %rdi, 8)
    0x400482: mov   $0x15213, %eax
    0x400487: retq
    0x400488: sub   $0x5, %edx
    0x40048b: lea   0x0(, %rdx, 4), %eax
    0x400492: retq
    0x400493: mov   $0x2, %edx
    0x400498: and   %edx, %esi
    0x40049a: lea   0x4(%rsi), %eax
    0x40049d: retq             
        \end{minted}
        补全主函数的 C 代码。
        \begin{minted}[frame=single, fontsize=\small]{c}
    // a in %rdi, b in %rsi, c in %rdx
    int main(int a, int b, int c) {
        int res = 4;
        switch (a) {
            case 0:
            case 1:
                __________;
            case ___:
                res = __________;
                break;
            case ___:
                res = __________;
                break;
            case 3:
                __________;
            case 7:
                __________;
            default:
                __________;
        }
        return res;
    }
        \end{minted}
        \sol 做法是首先根据跳转表, 确定各标号的起始地址, 然后再作汇编代码的对应. 答案如下所示：
        \begin{minted}[frame=single, fontsize=\small]{c}
    case 0:
    case 1:
        c = c - 5;
    case 2:
        res = 4 * c; // or res *= c
        break;
    case 5:
        res = 86547; // or 0x15213
        break;
    case 3:
        c = 2;
    case 7:
        b = b & c;
    default:
        res += b; // or res = b + 4
        \end{minted}
        \pro 将下列汇编代码翻译成 C 代码。
        \begin{minted}[frame=single, fontsize=\small]{text}
    func:
        movq   %rsi, %rax
        testq  %rdi, %rdi
        jne    .L7
        rep ret
    .L7:
        subq   $8, %rsp
        imulq  %rdi, %rax
        movq   %rax, %rsi
        subq   $1, %rdi
        call   func
        addq   $8, %rsp
        ret
        \end{minted}
        \begin{minted}[frame=single, fontsize=\small]{c}
    long func(long n, long m) {
        if (__________)
            return __________;
        return func(__________, __________);
    }
        \end{minted}
        \pro 将下列 C 代码翻译为汇编代码。
        \begin{minted}[frame=single, fontsize=\small]{c}
    void callee(long *a, long *b) {
        if (a == b) return;
        *a ^= *b;
        *b ^= *a;
        *a ^= *b;
    }
    void caller(long n, long arr[]) {
        for (long i = 0; i < n/2; i++)
            callee(&arr[i], &arr[n-i]);
    }
        \end{minted}
        汇编代码为:
        \begin{minted}[frame=single, fontsize=\small]{text}
    callee:
        cmpq   %rsi, %rdi
        je     .L1
        movq   (%rsi), %rax
        xorq   (%rdi), %rax
        movq   ____________
        xorq   (%rsi), %rax
        movq   %rax, (%rsi)
        xorq   %rax, (%rdi)
    .L1:
        rep ret

    caller:
        pushq  %r12
        pushq  %rbp
        pushq  %rbx
        movq   %rdi, %rbp
        movq   %rsi, %r12
        movl   $0, %ebx
        jmp    .L4
    .L5:
        movq   %rbp, %rax
        subq   %rbx, %rax
        ____   (%r12, %rax, ____), %rsi
        ____   (%r12, %rbx, ____), %rdi
        call   callee
        addq   $1, %rbx
    .L4:
        movq   %rbp, %rax
        shrq   $63, %rax
        addq   %rbp, %rax
        sarq   %rax
        cmpq   %rbx, %rax
        jg     .L5
        popq   ____
        popq   ____
        popq   ____
        ret
        \end{minted}
        
        对于上面代码，在 x86-64、操作系统为 Linux 的情况下，假设 main 在 \verb|0x4000ac| 处调用 caller， caller 在 \verb|0x400088| 处调用 callee；调用函数（\verb|call xx|）的代码长度为 5。在 main 即将调用 caller 时，部分寄存器的情况见下表左侧。请在下图右侧画出控制流第一次走 到 \verb|.L1| 时，堆栈的结构。
        \begin{table}[H]
            \centering
            \begin{tabular}{|c|c|c|c|}
                \hline
                寄存器 & 调用前的值 & 地址 & 内容（不确定的空格不用填） \\ \hline
                \verb|%rsp| & \verb|0xffffffffff80| & \verb|0xf...f88~8f| &  \\ \hline
                \verb|%rax| & \verb|0x0| & \verb|0xf...f80~87| &  \\ \hline
                \verb|%rbx| & \verb|0x15| & \verb|0xf...f78~7f| &  \\ \hline
                \verb|%rbp| & \verb|0x18| & \verb|0xf...f70~77| &  \\ \hline
                \verb|%r12| & \verb|0x213| & \verb|0xf...f68~6f| &  \\ \hline
                \verb|%rsi| & \verb|0x0| & \verb|0xf...f60~67| &  \\ \hline
                \verb|%rdi| & \verb|0x0| & \verb|0xf...f58~5f| &  \\ \hline
                &  & \verb|0xf...f50~57| &  \\ \hline
            \end{tabular}
        \end{table}
        \sol 阅读 \verb|callee| 汇编代码可知，首先 \verb|*b| 进入 \verb|%rax|，随后 \verb|%rax| 变为 \verb|*a ^ *b|。根据 C 代码确定下一步要将结果转入 \verb|*a| 中，所以汇编语言代码的空应填写 \verb|%rax, %(rdi)|。\verb|caller| 汇编代码的阅读不需要太仔细(就做题而言)，极易填写。注意这里体现的典型的 \verb|for| 循环结构，快速识别 \verb|%ebx| 为循环变量，\verb|.L4| 后为循环条件检查。后者需要计算 \verb|n / 2|，要留意编译器选择用移位作除法，但是对于负数需要作修正(舍入方式不同)。\verb|sarq| 等移位操作若只有一个操作数，则移位量默认为 1。

        此处栈空间的填写难度不大。首先，\verb|main| 即将发生调用时，\verb|%rsp| 值为 \verb|0xf...f80|，接下来 \verb|call| 后需要在栈中设置返回地址，这个返回地址为 \verb|0x4000ac + 0x5 = 0x4000b1|。所以栈的第三个空填此。注意栈是向下增长的，所以前两个空不确定。接下来 \verb|caller| 要保存 \verb|%r12, %rbp, %rbx| 三个寄存器，因此先后填入 \verb|0x213, 0x18, 0x15|。最后，\verb|callee| 被调用，需要再次填入返回地址 \verb|0x400088 + 0x5 = 0x40008d|。最后一个空显然不确定。
        \pro 在 x86-64、Linux 操作系统下有如下 C 定义：
        \begin{minted}[frame=single, fontsize=\small]{c}
    struct A {
        char CC1[6];
        int II1;
        long LL1;
        char CC2[10];
        long LL2;
        int II2;
    };
        \end{minted}
            \qn \verb|sizeof(A) = |\rule{2.5cm}{0.25mm}。
            \qn 将 \texttt{A} 重排后，令结构体尽可能小，那么得到的新的结构体大小为 \rule{2.5cm}{0.25mm} 字节。
        \sol 解题时不妨用框图的形式把整个结构的内存布局画出来并标好偏移量。\verb|CC1| 从位置 0 开始；整数 4 字节对齐，所以 \verb|II1|从位置 8 开始；长整数 8 字节对齐，所以 \verb|LL1| 必须从位置 16 开始；而后的字符数组 \verb|CC2| 延展到位置 34，仍由长整数 8 字节对齐，\verb|LL2| 只好从位置 40 开始；最后的整数从位置 48 开始，现在总大小为 52 字节。在结构体后面再放一个相同的 \verb|A|，发现需要再补 4 字节才能使得第二个 \verb|A| 的 \verb|LL1| 对齐，所以第一问为 56 字节。第二问：可以重排顺序为 \verb|LL1 LL2 II1 II2 CC1 CC2|，刚好没有空白空间，得到的大小为 40 字节。显然这个可以用贪心法来做（先放对齐要求高的元素）。
        \pro 在 x86-64、LINUX 操作系统下，考虑如下的 C 定义：
        \begin{minted}[frame=single, fontsize=\small]{c}
    typedef union {
        char c[7];
        short h;
    } union_e;

    typedef struct {
        char d[3];
        union_e u;
        int i;
    } struct_e;

    struct_e s;
        \end{minted}
            \qn \verb|s.u.c| 的首地址相对于 \verb|s| 的首地址的偏移量是 \rule{2.5cm}{0.25mm} 字节。
            \qn \verb|sizeof(union_e) = |\rule{2.5cm}{0.25mm} 字节。
            \qn \verb|s.i| 的首地址相对于 \verb|s| 的首地址的偏移量是 \rule{2.5cm}{0.25mm} 字节。
            \qn \verb|sizeof(struct_e) = |\rule{2.5cm}{0.25mm} 字节。
            \qn 若只将 \verb|i| 的类型改成 \verb|short|，那么 \verb|sizeof(struct_e) = |\rule{2.5cm}{0.25mm} 字节。
            \qn 若只将 \verb|h| 的类型改成 \verb|int|，那么 \verb|sizeof(union_e) = |\rule{2.5cm}{0.25mm} 字节。
            \qn 若将 \verb|i| 的类型改成 \verb|short|、\verb|h| 的类型改成 \verb|int|，则 \verb|sizeof(union_e) = |\rule{2.5cm}{0.25mm} 字节，\verb|sizeof(struct_e) = |\rule{2.5cm}{0.25mm} 字节。
            \qn 若只将 \verb|short h| 的定义删除，那么 (1)\textasciitilde(4) 问的答案分别是 \rule{1cm}{0.25mm}、\rule{1cm}{0.25mm}、\rule{1cm}{0.25mm}、\rule{1cm}{0.25mm} 字节。
        \sol 本题的主要难点是确定 \verb|union, struct| 本身的对齐，方法一般是在结构或联合后面再放一个相同的对象，构成数组，看需要补多少字节才能使得第二个元素对齐（对齐要求的是每个基本数据类型对齐！）。经验规则是按其中对齐要求最严格的元素进行这一工作。

        根据对齐规则，题给 \verb|union| 只需要 7 字节就能使得内部对齐，但是后面接一个同样的对象时 \verb|short| 需要 2 字节对齐，所以它实际上为 8 字节，且要求 2 字节对齐。这样我们就知道 \verb|struct| 的大小为 $3 + \underline 1 + 8+4=16$ 字节。由此，前 4 空答案为 4、8、12、16。同理可以得到后面几问的答案，为 14、8、8、16、(3、7、12、16)。
        \pro 以下提供了一段代码的 C 语言、汇编语言以及运行到某一时刻栈的情况。
        \begin{minted}[frame=single, fontsize=\small]{text}
0000000000400596 <func>: 
    400596: sub    $0x28, %rsp
    40059a: mov    %fs:0x28, %rax
    4005a3: mov    %rax, 0x18(%rsp)
    4005a8: xor    %eax, %eax
    4005aa: mov    (%rdi), %rax
    4005ad: mov    0x8(%rdi), %rdx
    4005b1: cmp    %rdx, %rax
    4005b4: jge    _____(1)_____
    4005b6: mov    %rdx, (%rdi)
    4005b9: mov    %rax, 0x8(%rdi)
    4005bd: mov    0x8(%rdi), %rax
    4005c1: test   %rax, %rax
    4005c4: jne    4005cb <func+0x35>
    4005c6: mov    (%rdi), %rax
    4005c9: jmp    _____(2)_____
    4005cb: mov    (%rdi), %rdx
    4005ce: sub    %rax, %rdx
    4005d1: mov    %rdx, (%rsp)
    4005d5: mov    %rax, 0x8(%rsp)
    4005da: mov    _____(3)_____, %rdi
    4005dd: callq  400596 <func>
    4005e2: mov    0x18(%rsp), %rcx
    4005e7: xor    _____(4)_____, %rcx
    4005f0: _____(5)_____    4005f7 <func+0x61>
    4005f2: callq  400460 <__stack_chk_fail@plt>
    4005f7: add    _____(6)_____, %rsp
    4005fb: retq
 
00000000004005fc <main>: 
    4005fc: sub    $0x28, %rsp 
    400600: mov    %fs:0x28, %rax 
    400609: mov    %rax, 0x18(%rsp) 
    40060e: xor    %eax, %eax 
    400610: movq   0x69, (%rsp) 
    400618: movq   0xfc, 0x8(%rsp) 
    400621: mov    %rsp, %rdi 
    400624: callq  400596 <func>
    400629: mov    %rax, %rsi
    40062c: mov    $0x4006e4, %edi
    400631: mov    $0x0, %eax
    400636: callq  400470 <printf@plt>
    40063b: mov    0x18(%rsp), %rdx
    400640: xor    _____(4)_____, %rdx
    400649: _____(5)_____    400650 <main+0x54>
    40064b: callq  400460 <__stack_chk_fail@plt>
    400650: mov    $0x0, %eax
    400655: add    _____(6)_____, %rsp
    400659: retq
        \end{minted}
        C 语言代码：
        \begin{minted}[frame=single, fontsize=\small]{c}
    typedef struct{
        long a;
        long b;
    } pair_type;

    long func(pair_type *p) {
        if (p -> a < p -> b) {
            long temp = p -> a;
            p -> a = p -> b;
            p->b = temp;
        }
        if (_____(7)_____) {
            return p->a;
        }
        pair_type np;
        np.a = _____(8)_____;
        np.b = _____(9)_____;
        return func(&np);
    } 

    int main(int argc, char* argv[]) {
        pair_type np;
        np.a = _____(10)_____;
        np.b = _____(11)_____;
        printf("%ld", func(&np));
    }
        \end{minted}
        堆栈情况如下（从高地址向低地址列举）：
        {\tt \begin{compactenum}
            \item\ 0x0000000000000000
            \item\ 0xc76d5add7bbeaa00 
            \item\ 0x00007fffffffdf60 
            \item\ \verb|__________________|
            \item\ \verb|__________________|
            \item\ 0x0000000000400629 
            \item\ \verb|__________________|
            \item\ \verb|__________________|
            \item\ 0x0000000000000001 
            \item\ 0x0000000000000069 
            \item\ 0x0000000000000093 
            \item\ \verb|__________________|
            \item\ 0x00000000ff000000 
            \item\ \verb|__________________|
            \item\ 0x0000000000000000 
            \item\ \verb|__________________|
            \item\ \verb|__________________|
            \item\ \verb|__________________|
            \item\ 0x0000000000000000 
            \item\ \verb|__________________|
            \item\ \verb|__________________|
            \item\ 0x000000000000002a 
            \item\ 0x000000000000003f 
            \item\ 0x00000000004005e2 
        \end{compactenum}}
        一些可能用到的字符的 ASCII 码如下：
        \begin{table}[H]
            \centering
            \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
                \hline
                换行 & 空格 & \verb|"| & \verb|%| & \verb|(| & \verb|)| & \verb|,| & \verb|0| & \verb|A| & \verb|a| \\ \hline
                \verb|0x0a| & \verb|0x20| & \verb|0x22| & \verb|0x25| & \verb|0x28| & \verb|0x29| & \verb|0x2c| & \verb|0x30| & \verb|0x41| & \verb|0x61| \\ \hline
            \end{tabular}
        \end{table}

        回答下列问题。
            \qn gdb 下使用命令 \verb|x/4b 0x4006e4| 后（即查看 \verb|0x4006e4| 开始的 4 个字节，用 16 进制表示）得到的输出结果是 \rule{2.5cm}{0.25mm}。
            \qn 互相翻译 C 语言代码和汇编代码，补充缺失的空格（标号相同的为同一格）。
            \qn 补充栈的内容。使用16进制，可以不写前导多余的 0；对于给定已知条件后仍无法确定的值，填写“不确定”；已知程序运行过程中寄存器 \verb|%fs| 的值没有改变。
            \qn 程序运行结果是 \rule{2.5cm}{0.25mm}。
        \sol 这是典型的汇编综合题，需要同时结合 C 代码和汇编代码来观察。
        
        第一步先通读 C 代码，确定代码大意，便于在汇编中找一些对应的片段。然后来填写汇编代码。主要难点在厘清 C 语言变量，内存和寄存器的映射关系，确定代码的用途。先看主函数，前三行为金丝雀。接下来，\verb|0x69, 0xfc| 分别进入 \verb|%rsp, %rsp + 8| 对应的内存位置中。根据主函数唯一的 \verb|&np| 取局部变量地址，以及紧接着 \verb|%rsp| 被作为参数传入 \verb|func|，知道这就是 \verb|np| 结构体的初始化工作。所以 C 代码的第 10、11 空分别填写 105、252。

        接着，\verb|func| 的返回值被存入 \verb|%rsi|, 一个立即数（看上去像地址）被存入 \verb|%rdi|，然后调用 \verb|printf| 函数。结合 C 代码知道 \verb|%rdi| 是字符串 \verb|"%ld"|（属于 \verb|char*| 类型）的地址。所以由给出的 ASCII 码表计算得到问答题(1)应填写 \verb|0x25, 0x6c, 0x64, 0x00|。特别留意字符串的最后有一个 \verb|0x00| 表示结尾！主函数的最后几个空是检查金丝雀是否被破坏，易知金丝雀的原值在 \verb|%fs:0x28|，而在栈上对应于地址 \verb|%rsp + 0x18|（这个之后还要用到）。检查金丝雀是否被破坏是容易的，\verb|40063b| 先把后者放到 \verb|%rcx| 中，所以要比较 \verb|%fs:0x28, %rdx|，这就是空(4)的答案。接下来要条件跳转，因为如果条件成立会正常返回，所以空(5)写 \verb|je|。空(6)是函数返回释放栈空间，因为一开始分配了 \verb|0x28| 个字节，所以这个空也要填 \verb|0x28|。

        现在分析 \verb|func| 函数。前三行是金丝雀以及寄存器清零。从地址 \verb|4005aa| 开始分析，首先 \verb|p->a, p->b| 分别进入 \verb|%rax, %rdx| 中。接下来比较 \verb|p->a >= p->b|。结合 C 代码，如果这成立，就不需要经过交换 \verb|p->a, p->b| 的过程。立刻看出，\verb|4005b6, 4005b9| 两行完成了交换工作（没有出现 \verb|temp| 的对应寄存器映射）。由于不确定交换之后 \verb|%rax| 到底对应 \verb|p->a, p->b| 中的哪个，所以其要重新移入 \verb|p->b| 到 \verb|p->a| 中。所以 \verb|4005bd| 就是空(1)的跳转目标。接下来用 \verb|test| 指令判断 \verb|%rax| 是否为 0。注意 C 代码，如果某个条件成立，就要 \verb|return p->a|。因为 \verb|4005cb| 把 \verb|p->a| 放到 \verb|%rax| 中，所以空(2)会跳到函数结尾返回，也就是说跳转目标是 \verb|4005e2|（返回之前要检查金丝雀是否被破坏）。由此也可知只有 \verb|p->b| 为零时才返回，空(7)填写 \verb|p->b == 0|。

        紧接着处理 \verb|func| 的递归调用。结合 C 代码知道要生成新的 \verb|np|，而且 \verb|np.a, np.b| 分别在栈地址的 \verb|%rsp, %rsp + 8| 处。因为这时 \verb|p->a| 在 \verb|%rdx| 中，\verb|p->b| 在 \verb|%rax| 中，所以由 \verb|4005ce, 4005d1| 两行立刻知道(8)、(9)两空分别写 \verb|p->a - p->b, p->b|。

        补全 C 代码后，可以看出这是辗转相除法，输入是 252、105，它们的最大公约数是 21，故问答题的(4)回答 21。

        最后填写栈。对于递归调用，我们应该先正确划分各次调用的栈的边界。第一步，由于主函数和 \verb|func| 一开始都 \verb|subq 0x28, %rsp|，所以栈空间都有 40 字节或 5 个 64 位地址。注意 6 号位置是 \verb|0x400629|，恰好是主函数调用 \verb|func| 的返回地址，所以我们知道 1--5 号位置是主函数的栈帧，6 是从 \verb|func| 返回主函数的返回地址；7--11 是第一次调用 \verb|func| 的栈帧，12 是从第二次递归调用返回第一次调用 \verb|func| 的返回地址，13--17 是第二次调用 \verb|func| 的栈帧，以此类推。所以 12、18 都填 \verb|0x4005e2|（\verb|func| 中递归调用的下一条指令的位置）。
        
        第二步，根据前面的分析，每个栈的栈帧的底部向上数第一个和第二个数都是存储局部变量 \verb|np|（无论是主函数还是 \verb|func|），所以位置 4、5 似乎分别应该写上 \verb|0xfc, 0x69|。但是，注意后面的递归调用中，这两个位置的数会被交换以保证 \verb|p->a >= p->b|！所以这两个空要倒过来，4、5 分别写上 \verb|0x69, 0xfc|。第三步，由前面的分析，金丝雀值一直存在 \verb|%rsp + 0x18|，也就是栈帧自底向上第四个位置，又题目条件说 \verb|%fs| 寄存器没有改变，所以所有的金丝雀值都是 \verb|0xc76d5add7bbeaa00|，这样 8、14、20 都是这个值。

        对于栈的 10、11 号位置，前面的分析知道它们应该是 \verb|252 - 105, 105 = 0x93, 0x69|（顺序未定），而交换后保证上一个要小于下一个，所以 10、11 给出的情况印证我们的分析。同理，16、17 空是 \verb|0x93 - 0x69 = 0x2a, 0x69|，上一个要小于下一个。虽然 22、23 号位置不用填写，但是我们务必注意，栈在这个状态时，刚刚进行下一次递归调用，这两个数还没有被下一次递归调用修改顺序（尽管实际上不需要修改顺序）。

        栈的剩下位置，7、21 都是不确定的，因为只是分配了没有修改过。（注意栈帧开头应该不是旧的帧指针，因为如果要这样需要显式 \verb|push|。）
    \end{problems}

\chapter{汇编语言{---}往年考题}
    \begin{problems}
        \proy{2018} 在 x86-64 下，以下哪个选项的说法是错误的？
        \begin{choices}
            \item \verb|movl| 指令以寄存器作为目的时，会将该寄存器的高位 4 字节设置为 0
            \item \verb|cltq| 指令的作用是将 \verb|%eax| 符号扩展到 \verb|%rax|
            \item \verb|movabsq| 指令只能以寄存器作为目的
            \item \verb|movswq| 指令的作用是将零扩展的字传送到四字节目的
        \end{choices}
        \proy{2018} 下列关于程序控制结构的机器代码实现的说法中，正确的是：
        \begin{choices}
            \item 使用条件跳转语句实现的程序片段比使用条件赋值语句实现的同一程序片段的运行效率高
            \item 使用条件跳转语句实现的程序片段与使用条件赋值语句实现的同一程序片段虽然效率可能不同，但在 C 语言的层面上看总是有着相同的行为
            \item 一些 \verb|switch| 语句不会被 gcc 用跳转表的方式实现
            \item 以上说法都不正确
        \end{choices}
        \proy{2018} 下列关于条件码的叙述中，不正确的是：
        \begin{choices}
            \item 所有算术指令都会改变条件码
            \item 所有比较指令都会改变条件码
            \item 所有与数据传送有关的指令都会改变条件码
            \item 条件码一般不会直接读取，但可以直接修改
        \end{choices}
        \sol 此题有错，A、B 都不准确，有一些 SIMD 指令并不会改变条件码；C 明显是错的；D 基本正确，确实有指令可以直接写条件码。
        \proy{2017} 在下列的 x86-64 汇编代码中，错误的是：
        \begin{choices}
            \item \verb|movq %rax, (%rsp)|
            \item \verb|movl $0xFF, (%ebx)|
            \item \verb|movsbl (%rdi), %eax|
            \item \verb|leaq (%rdx, 1), %rdx|
        \end{choices}
        \sol 此题有错，B、D 都不对，其中 B 不能用 32 位寄存器寻址，D 中少了一个逗号。
        \proy{2017} 在下列关于条件传送的说法中，正确的是：
        \begin{choices}
            \item 条件传送可以用来传送字节、字、双字和四字的数据
            \item C语言中的“\verb|?:|”条件表达式都可以编译成条件传送
            \item 使用条件传送总可以提高代码的执行效率
            \item 条件传送指令不需要用后缀(例如 \verb|b, w, l, q|)来表明操作数的长度
        \end{choices}
        \proy{2017} 在下列指令中，其执行会影响条件码中的 CF 位的是：
        \begin{choices}
            \item \verb|jmp NEXT|
            \item \verb|jc NEXT|
            \item \verb|inc %bx|
            \item \verb|shl $1, %ax|
        \end{choices}
        \proy{2016} 下列关于比较指令 \verb|cmp| 说法中，正确的是：
        \begin{choices}
            \item 专用于有符号数比较
            \item 专用于无符号数比较
            \item 专用于串比较
            \item 不区分比较的对象是有符号数还是无符号数
        \end{choices}
        \proy{2016} 在如下代码段的跳转指令中，目的地址是：
        \begin{minted}[frame=single, fontsize=\small]{text}
    400020: 74 F0 je   ________
    400022: 5d    pop  %rbp
        \end{minted}
        \begin{choices}
            \item \texttt{400010}
            \item \texttt{400012}
            \item \texttt{400110}
            \item \texttt{400112}
        \end{choices}
        \proy{2016} 对于如下的 C 语言中的条件转移指令，它所对应的汇编代码中至少包含几条条件转移指令：\verb+if (a > 0 && a != 1 || a < 0 && a != -1) b = a;+？
        \begin{choices}
            \item 2 条
            \item 3 条
            \item 4 条
            \item 5 条
        \end{choices}
        \sol B，这个条件相当于 \verb+(a == 0 || a == 1 || a == -1)+。
        \proy{2016} 将 \verb|%ax| 清零，下列指令不能实现该效果的是：
        \begin{choices}
            \item \verb|sub %ax, %ax|
            \item \verb|xor %ax, %ax|
            \item \verb|test %ax, %ax|
            \item \verb|and $0, %ax|
        \end{choices}
        \proy{2016} 在如下 \verb|switch| 语句翻译得到的跳转表中，哪些标号没有出现在分支中？
        \begin{minted}[frame=single, fontsize=\small]{text}
    addq    $1, %rdi
    cmpq    $8, %rdi
    ja      .L2
    jmp     *.L4(, %rdi, 8)
    .L4:
        .quad .L9
        .quad .L5
        .quad .L6
        .quad. L7
        .quad .L2
        .quad .L7
        .quad .L8
        .quad .L2
        .quad .L5
        \end{minted}
        \begin{choices}
            \item 3, 6
            \item $-1$, 4
            \item 0, 7
            \item 2, 4
        \end{choices}
        \proy{2016} 已知短整型数组 \verb|S| 的起始地址和下标 \verb|i| 分别存放在寄存器 \verb|%rdx| 和 \verb|%rcx|，将 \verb|&S[i]| 存放在寄存器 \verb|%rax| 中所对应的汇编代码是：
        \begin{choices}
            \item \verb|leaq (%rdx, %rcx, 1), %rax|
            \item \verb|movw (%rdx, %rcx, 2), %rax|
            \item \verb|leaq (%rdx, %rcx, 2), %rax|
            \item \verb|movw (%rdx, %rcx, 1), %rax|
        \end{choices}
        \proy{2015} 下列寻址模式中，正确的是：
        \begin{choices}
            \item \verb|(%eax, , 4)|
            \item \verb|(%eax, %esp, 3)|
            \item \verb|123|
            \item \verb|$1(%ebx, %ebp, 1)|
        \end{choices}
        \proy{2015} 假设某条 C 语言 \verb|switch| 语句编译后产生了如下的汇编代码及跳转表：
        \begin{minted}[frame=single, fontsize=\small]{text}
    movl   8(%ebp), %eax
    subl   $48, %eax
    cmpl   $8, %eax
    ja     .L2
    jmp    *.L7(, %eax, 4)
    .L7:
        .long .L3
        .long .L2
        .long .L2
        .long .L5
        .long .L4
        .long .L5
        .long .L6
        .long .L2
        .long .L3
        \end{minted}
        在源程序中，下面的哪些标号出现过？
        \begin{choices}
            \item \verb|'2', '7'|
            \item \verb|1|
            \item \verb|'3'|
            \item \verb|5|
        \end{choices}
        \sol C，从 \verb|subl| 可看出待比较的数是字符型。
        \proy{2015, 2014} 下列的指令组中，哪一组指令只改变条件码，而不改变寄存器的值？
        \begin{choices}
            \item \verb|CMP, SUB|
            \item \verb|TEST, AND|
            \item \verb|CMP, TEST|
            \item \verb|LEAL, CMP|
        \end{choices}
        \proy{2014} 简单的 \verb|switch| 语句常采用跳转表的方式实现，在 x86-64 系统中，下述最有可能是正确的 \verb|switch| 分支跳转汇编指令的是哪个？
        \begin{choices}
            \item \verb|jmp .L3(, %eax, 4)|
            \item \verb|jmp .L3(, %eax, 8)|
            \item \verb|jmp *.L3(, %eax, 4)|
            \item \verb|jmp *.L3(, %eax, 8)|
        \end{choices}
        \proy{2018} 以下代码的输出结果不可能是
        \begin{minted}[frame=single, fontsize=\small]{c}
    union {
        double d;
        struct {
            int i;
            char c[4];
        } s;
    } u;
    u.d = 1;
    printf("%d\n", u.s.c[2]);
        \end{minted}
        \begin{choices}
            \item 0
            \item $-16$
            \item 240
            \item 191
        \end{choices}
        \sol D。题目没有说明大小端，如果是大端法则为 A。若为小端法，注意 \verb|char| 在不同的编译器上可能是有符号型或者是无符号型，所以计算知 $-16$ 和 240 都有可能。
        \proy{2018} 下列关于 C 语言中的结构体（struct）以及联合（union）的说法中，正确的是：
        \begin{choices}
            \item 对于任意 struct，将其成员按照其实际占用内存大小从小到大的顺序进行排列不一定会使之内存占用最小
            \item 对于任意 struct，将其成员按照其实际占用内存大小从小到大的顺序进行排列一定不会使之内存占用最大
            \item 对于任意 union，将其成员按照其实际占用内存大小从小到大的顺序进行排列不一定会使之内存占用最小
            \item 对于任意 union，将其成员按照其实际占用内存大小从小到大的顺序进行排列一定不会使之内存占用最大
        \end{choices}
        \proy{2017} 有如下代码段：
        \begin{minted}[frame=single, fontsize=\small]{c}
    int func(int x, int y);
    int (*p) (int a, int b);
    p = func;
    p(0, 0);
        \end{minted}
        对应的下列 x86-64 过程调用正确的是：
        \begin{choices}
            \item \verb|call *%rax|
            \item \verb|call *(%rax)|
            \item \verb|call (%rax)|
            \item \verb|call func|
        \end{choices}
        \sol 此题有错，A、D 都可能产生（和优化选项有关）。
        \proy{2017} 有定义：\verb|int A[3][2] = {{1,2}，{3,3}，{2,1}};|，则 \verb|A[2]| 是：
        \begin{choices}
            \item \verb|&A + 16|
            \item \verb|A + 16|
            \item \verb|*A + 4|
            \item \verb|*A + 2|
        \end{choices}
        \proy{2015} 已知下面的数据结构，假设在 Linux/IA32 下要求对齐，这个结构的总的大小是多少个字节？如果重新排列其中的字段，最少可以达到多少个字节？
        \begin{minted}[frame=single, fontsize=\small]{c}
    struct {
        char a;
        double *b;
        double c;
        short d;
        long long e;
        short f;
    };
        \end{minted}
        \begin{choices}
            \item 32, 28
            \item 36, 32
            \item 28, 26
            \item 26, 26
        \end{choices}
        \proy{2015} 在“大端法”下，已知如下的 C 语言数据结构：\verb|union { char c[2]; int i; };|。当 \verb|c| 的值为 \verb|0x01, 0x23| 时，\verb|i| 的值为：
        \begin{choices}
            \item \verb|0x0123|
            \item \verb|0x2301|
            \item \verb|0x01230000|
            \item 不确定
        \end{choices}
        \proy{2014} 有如下定义的结构，在 x86-64 下，下述结论中错误的是？
        \begin{minted}[frame=single, fontsize=\small]{c}
    struct {
        char c;
        union {
            char vc;
            double value;
            int vi;
        } u;
        int i;
    } sa;
        \end{minted}
        \begin{choices}
            \item \verb|sizeof(sa) == 24|
            \item \verb|(&sa.i - &sa.u.vi) == 8|
            \item \verb|(&sa.u.vc - &sa.c) == 8|
            \item 优化成员变量的顺序，可以做到 \verb|sizeof(sa) == 16|
        \end{choices}
        \proy{2013} 32 位 x86、Windows 操作系统下定义 struct \verb|S| 包含: \verb|double a, int b, char c|, 请问 \verb|S| 在内存空间中最多和最少分别能占据多少个字节（32 位 Windows 系统按 1、4、8 的原则对齐 \verb|char, int, double|）？
        \begin{choices}
            \item 16, 13
            \item 16, 16
            \item 24, 13
            \item 24, 16
        \end{choices}
        \proy{2018} 假设在 64 位 Linux 机器上有数据结构定义如下：
        \begin{minted}[frame=single, fontsize=\small]{c}
    typedef struct s1 {
        char cc[N];
        int ii[N];
        int *ip;
    } S1;
    
    S1 t1[N];
        \end{minted}
        \qn 分别确定当 $N=3, 4, 5$ 时，\verb|sizeof(S1)| 和 \verb|sizeof(T1)| 的输出。
        \qn 当 $N=4$ 时，该数据结构初始化代码如下: 
        \begin{minted}[frame=single, fontsize=\small]{c}
    void init(int n) {
        int i;
        for (i = 0; i < n; i++) {
            t1[i].ip = &(t1[i].ii[i]);
        }
    }
        \end{minted}
        根据上述代码，填写下面汇编中缺失的内容：
        \begin{minted}[frame=single, fontsize=\small]{text}
    init:
        movl    $0, %ecx
        jmp     .L2

    .L3:
        movslq  %ecx, %rax
        leaq    (_____, %rax, 8), %rsi
        leaq    0(, %rsi, 4), %rdx
        addq    $t1+4, %rdx
        salq    _____, %rax
        movq    _____, _____
        addl    $1, %ecx

    .L2
        cmpl    _____, %ecx
        jl      .L3
        rep ret
        \end{minted}
        \qn 当 $N=3$ 时，函数 \verb|fun| 的汇编代码如下：
        \begin{minted}[frame=single, fontsize=\small]{text}
    fun:
        movslq   %esi, %rax
        movslq   %edi, %rdi
        leaq     (%rdi, %rdi), %rdx
        leaq     (%rdx, %rdi), %r8
        leaq     (%r8, %r8), %rcx
        addq     %rcx, %rax
        movl     %esi, t1+4(, %rax, 4)
        addq     %rdx, %rdi
        leaq     0(, %rdi, 8), %rax
        movq     t1+16(%rax), %rax
        movl     %esi, (%rax)
        ret
        \end{minted}
        根据上述代码，填写函数 \verb|fun| 的 C 语言代码：
        \begin{minted}[frame=single, fontsize=\small]{c}
    void fun(int x, int y) {
        __________ = __________;
        __________ = __________;
    }
        \end{minted}
        \proy{2017} 分析下面 C 语言程序和相应的 x86-64 汇编程序，请填写缺失的内容。
        \begin{minted}[frame=single, fontsize=\small]{c}
    #include <stdio.h>
    #include "string.h"

    void myprint(char *str) {
        char buffer[16];
        __________(buffer, str);
        printf("%s \n", buffer);
    }

    void alert(void) {
        printf("__________\n");
    }

    int main(int argc, char *argv[]) {
        myprint("1234567123456712345671234567\xaa\x84\x04\x08");
        return 0;
    }
        \end{minted}
        \begin{minted}[frame=single, fontsize=\small]{text}
        .section .rodata
    .LC0:
        .string  "___________"
        .text
        .globl   myprint
        .type    myprint, @function
    myprint:
    .LFB0:
        .cfi_startproc
        pushq    %rbp
        .cfi_def_cfa_offset 16
        .cfi_offset 6, -16
        movq     %rsp, %rbp
        .cfi_def_cfa_register 6
        subq     $48, __________
        movq     %rdi, -40(%rbp)
        movq     %fs:40, __________
        movq     %rax, -8(%rbp)
        xorl     %eax, %eax
        movq     __________, %rdx
        leaq     -32(%rbp), %rax
        movq     %rdx, __________
        ______________________________
        call     strcpy
        ____     -32(%rbp), %rax
        movq     %rax, %rsi
        movl     $.LC0, %edi
        movl     $0, %eax
        call     printf
        nop
        ____     __________, %rax
        xorq     __________, __________
        je       __________
        call     __stack_chk_fail
    .L2:
        leave
        .cfi_def_cfa 7, 8
        ret
        .cfi_endproc

    .LFE0:
        .size    myprint, .-myprint
        .section .rodata
    .LC1:
        .string  "Where am I?"
        .text
        .globl   alert
        .type    alert, @function
    alert:
    .LFB1:
        .cfi_startproc
        pushq    %rbp
        .cfi_def_cfa_offset 16
        .cfi_offset 6, -16
        movq     %rsp, %rbp
        .cfi_def_cfa_register 6
        movl     $.LC1, %edi
        call     puts
        nop
        popq     %rbp
        .cfi_def_cfa 7, 8
        ______________________________
        .cfi_endproc

    .LFE1:
        .size    alert, .-alert
        .section .rodata
        .align 8
    .LC2:
        .string  "1234567123456712345671234567\252\___\004\b"
        .text
        .globl   main
        .type    main, @function
    main:
        .LFB2:
        .cfi_startproc
        pushq   %rbp
        .cfi_def_cfa_offset 16
        .cfi_offset 6, -16
        movq    %rsp, %rbp
        .cfi_def_cfa_register 6
        subq    $16, %rsp
        movl    %edi, -4(%rbp)
        movq    %rsi, -16(%rbp)
        movl    $.LC2, %edi
        ______________________________
        movl    $0, %eax
        leave
        .cfi_def_cfa 7, 8
        ret
        .cfi_endproc
    .LFE2:
        .size   main, .-main
        \end{minted}
        \proy{2015} 在 32 位机器中，有如下声明。
        \begin{minted}[frame=single, fontsize=\small]{c}
    union ELE {
        struct {
            int x;
            int *p;
        } e1;
        struct {
            union ELE *next;
            int y;
        } e2;
    };
        \end{minted}
        \qn 上面的 \verb|union| 有几个字节？
        \qn 假设编译器为 \verb|process| 函数产生了如下了代码，请补充完整下面的过程。已知只有一个不需要任何强制类型转换且不违反任何类型限制的答案。
        \begin{minted}[frame=single, fontsize=\small]{text}
    movl    8(%ebp), %eax
    movl    (%eax), %ecx
    movl    4(%ecx), %edx
    movl    (%edx), %edx
    subl    4(%eax), %edx
    movl    %edx, (%ecx)
        \end{minted}
        \begin{minted}[frame=single, fontsize=\small]{c}
    void process(union ELE * up) {
        up->__________ = __________ - __________;
    }
        \end{minted}
        \qn 假设整型变量 \verb|n| 在栈中 \verb|%ebp + 8| 位置，\verb|ELE*| 型变量 \verb|up| 在栈中 \verb|%ebp + 12| 位置。已知以 \verb|*up| 为头元素（记为第 0 个），由声明中的 \verb|next| 指针连接形成了一个链表，现在希望将第 \verb|n| 个元素（假设链表足够长）的 \verb|x| 的值放入 \verb|%eax| 中。以下完成该功能的汇编代码有错，请找出所有错误并改正。
        \begin{minted}[frame=single, fontsize=\small]{text}
        xorl    %ecx, %ecx
        movl    8(%edx), %ebp
        movl    12(%ebp), %eax
    LOOP:
        movl    (%eax), %eax
        add     $1, %ecx
        test    %ecx, %edx
        jne     LOOP
        movl    (%eax), %eax
        \end{minted}
        \qn 阅读下列代码，回答后面的问题。
        \begin{minted}[frame=single, fontsize=\small]{c}
    typedef struct {
        short x[A][B];
        int y;
    } str1;

    typedef struct {
        char array[B];
        int t;
        short s[B];
        int u;
    } str2;

    void setVal(str1 *p, str2 *q) {
        int v1 = q->t;
        int v2 = q->u;
        p->y = v1 + v2;
    }
        \end{minted}
        编译器为 \verb|setVal| 产生下面的代码：
        \begin{minted}[frame=single, fontsize=\small]{text}
    movl    12(%ebp), %eax
    movl    28(%eax), %edx
    addl    8(%eax), %edx
    movl    8(%ebp), %eax
    movl    %edx, 44(%eax)
        \end{minted}
        给出 \verb|A, B| 的值。
        \proy{2014} 一个函数如下，其中部分代码被隐去。
        \begin{minted}[frame=single, fontsize=\small]{c}
    int f(int n, int m) {
        if (m > 0) {
            if (____________________) {
                int r = ____________________;
                return ____________________;
            }
            else if (____________________) {
                return 1;
            }
        }
        return 0;
    }
        \end{minted}
        如下是通过 \verb|gcc –g –O2| 命令编译后，在 gdb 中通过 \verb|disas f| 命令得到的反汇编代码，其中有两个汇编指令不全。
        \begin{minted}[frame=single, fontsize=\small]{text}
    0x00000000004004e0 <f+0>:     mov     %rbx, -0x10(%rsp)
    0x00000000004004e5 <f+5>:     mov     ____________________
    0x00000000004004ea <f+10>:    xor     %eax, %eax
    0x00000000004004ec <f+12>:    sub     $0x10, %rsp
    0x00000000004004f0 <f+16>:    test    %esi, %esi
    0x00000000004004f2 <f+18>:    mov     %edi, %ebp
    0x00000000004004f4 <f+20>:    mov     %esi, %ebx
    0x00000000004004f6 <f+22>:    jle     0x400513 <f+51>
    0x00000000004004f8 <f+24>:    cmp     $0x1, %edi
    0x00000000004004fb <f+27>:    jle     0x400521 <f+65>
    0x00000000004004fd <f+29>:    lea     -0x1(%rbp), %edi
    0x0000000000400500 <f+32>:    callq   0x4004e0 <f>
    0x0000000000400505 <f+37>:    lea     -0x1(%rax, %rbx, 1), %edx
    0x0000000000400509 <f+41>:    mov     %edx, %eax
    0x000000000040050b <f+43>:    sar     $0x1f, %edx
    0x000000000040050e <f+46>:    idiv    %ebp
    0x0000000000400510 <f+48>:    lea     0x1(%rdx), %eax
    0x0000000000400513 <f+51>:    mov     ____________________
    0x0000000000400517 <f+55>:    mov     0x8(%rsp), %rbp
    0x000000000040051c <f+60>:    add     $0x10, %rsp
    0x0000000000400520 <f+64>:    retq
    0x0000000000400521 <f+65>:    sete    %al
    0x0000000000400524 <f+68>:    movzbl  %al, %eax
    0x0000000000400527 <f+71>:    jmp     0x400513 <f+51>
        \end{minted}
        \qn 补全 C 代码和汇编指令。
        \qn 已知在调用函数 \verb|f(4, 3)| 时，我们在函数 \verb|f| 中指令 \verb|retq| 处设置了断点，下面列出的是程序在第一次运行到断点处暂停时时，相关通用寄存器的值。
        \begin{compactdesc}
            \item[\texttt{\%rax}] \verb|0x3|
            \item[\texttt{\%rcx}] \verb|0x3|
            \item[\texttt{\%rdx}] \verb|0x309c552970|
            \item[\texttt{\%rsi}] \verb|0x3|
            \item[\texttt{\%rdi}] \verb|0x1|
            \item[\texttt{\%rbp}] \verb|0x2|
            \item[\texttt{\%rsp}] \verb|0x7fffffffe340|
            \item[\texttt{\%rip}] \verb|0x400520|
        \end{compactdesc}
        请根据你对函数及其汇编代码的理解，填写当前栈中的内容。如果某些内存位置处内容不确定，请填写 \verb|X|。
        \begin{compactdesc}
            \item[\texttt{0x7fffffffe38c}] \verb|____________________|
            \item[\texttt{0x7fffffffe388}] \verb|____________________|
            \item[\texttt{0x7fffffffe384}] \verb|____________________|
            \item[\texttt{0x7fffffffe380}] \verb|____________________|
            \item[\texttt{0x7fffffffe37c}] \verb|____________________|
            \item[\texttt{0x7fffffffe378}] \verb|____________________|
            \item[\texttt{0x7fffffffe374}] \verb|____________________|
            \item[\texttt{0x7fffffffe370}] \verb|____________________|
            \item[\texttt{0x7fffffffe36c}] \verb|____________________|
            \item[\texttt{0x7fffffffe368}] \verb|____________________|
            \item[\texttt{0x7fffffffe364}] \verb|____________________|
            \item[\texttt{0x7fffffffe360}] \verb|____________________|
            \item[\texttt{0x7fffffffe35c}] \verb|____________________|
            \item[\texttt{0x7fffffffe358}] \verb|____________________|
            \item[\texttt{0x7fffffffe354}] \verb|____________________|
            \item[\texttt{0x7fffffffe350}] \verb|____________________|
            \item[\texttt{0x7fffffffe34c}] \verb|____________________|
            \item[\texttt{0x7fffffffe348}] \verb|____________________|
            \item[\texttt{0x7fffffffe344}] \verb|____________________|
            \item[\texttt{0x7fffffffe340}] \verb|____________________|
            \item[\texttt{0x7fffffffe33c}] \verb|____________________|
            \item[\texttt{0x7fffffffe338}] \verb|____________________|
            \item[\texttt{0x7fffffffe334}] \verb|____________________|
            \item[\texttt{0x7fffffffe330}] \verb|____________________|
            \item[\texttt{0x7fffffffe32c}] \verb|____________________|
            \item[\texttt{0x7fffffffe328}] \verb|____________________|
            \item[\texttt{0x7fffffffe324}] \verb|____________________|
            \item[\texttt{0x7fffffffe320}] \verb|____________________|
        \end{compactdesc}
        \proy{2014} 阅读下面的汇编代码，根据汇编代码填写 C 代码中缺失的部分，然后描述该程序的功能。
        \begin{minted}[frame=single, fontsize=\small]{text}
        pushl    %ebp
        movl     %esp,%ebp
        movl     $0x0, %ecx
        cmpl     $0x0, 8(%ebp)
        jle      .L1
    .L2
        movl     $0x0, %edx
        movl     8(%ebp), %eax
        divl     $0x0a
        addl     %edx, %ecx
        movl     %eax, 8(%ebp)
        cmpl     $0x0, 8(%ebp)
        jg       .L2
    .L1
        movl     0x0, %edx
        movl     %ecx, %eax
        divl     0x3
        cmpl     0x0, %edx
        jne      .L3
        movl     0x1, %eax
        jmp      .L4
    .L3
        movl     0x0, %eax
    .L4 
        \end{minted}
        \begin{minted}[frame=single, fontsize=\small]{c}
    int fun(_____ x) {
        int bit_sum = 0;
        while (_______________) {
            ____________________;
            ____________________;
        }
        if (_______________) {
            return 1;
        } else {
            return 0;
        }
    }
        \end{minted}
        \proy{2013} 阅读下面的 C 代码：
        \begin{minted}[frame=single, fontsize=\small]{c}
    /**
     * int_sqrt - rough approximation to sqrt
     * @x: integer of which to calculate the sqrt
     *
     * A very rough approximation to the sqrt() function.
     */ 
    unsigned long int_sqrt(unsigned long x) {
        unsigned long b, m, y = 0;
        if (x <= 1) 
            return x; 
        m = 1UL << (BITS_PER_LONG - 2); 
        while (m != 0) {
            b = y + m; 
            y >>= 1; 
            if (x >= b) {
                x -= b;
                y += m; 
            } 
            m >>= 2; 
        } 
        return y; 
    } 
        \end{minted}
        已知在 64 位的机器上 \verb|BITS_PER_LONG| 的定义为 \verb|long| 类型的位宽。请根据代码填写下面的汇编指令：
        \begin{minted}[frame=single, fontsize=\small]{text}
    4004c4: push   %rbp
    4004c5: mov    %rsp, %rbp
    4004c8: mov    %rdi, -0x28(%rbp)
    4004cc: movq   __________, -0x8(%rbp)
    4004d4: cmpq   $0x1, -0x28(%rbp)
    4004d9: ja     __________ <int_sqrt+??>
    4004db: mov    -0x28(%rbp), %rax
    4004df: jmp    __________ <int_sqrt+??>
    4004e1: movl   $0x0, -0x10(%rbp)
    4004e8: movl   __________, -0xc(%rbp)
    4004ef: jmp    __________ <int_sqrt+??>
    4004f1: mov    -0x10(%rbp), %rax
    4004f5: mov    -0x8(%rbp), %rdx
    4004f9: lea    __________, %rax
    4004fd: mov    %rax, -0x18(%rbp)
    400501: shrq   -0x8(%rbp)
    400505: mov    -0x28(%rbp), %rax
    400509: cmp    -0x18(%rbp), %rax
    40050d: jb     __________ <int_sqrt+??>
    40050f: mov    -0x18(%rbp), %rax
    400513: sub    %rax, -0x28(%rbp)
    400517: mov    -0x10(%rbp), %rax
    40051b: add    %rax, -0x8(%rbp)
    40051f: shrq   __________, -0x10(%rbp)
    400524: cmpq   $0x0, -0x10(%rbp)
    400529: jne    __________ <int_sqrt+??>
    40052b: mov    -0x8(%rbp), __________
    40052f: leaveq
    400530: retq
        \end{minted}
        \proy{2013} 某单参数函数 \verb|f| 的主体的汇编代码如下：
        \begin{minted}[frame=single, fontsize=\small]{text}
    4004c4: push   %rbp
    4004c5: mov    %rsp, %rbp
    4004c8: sub    $0x10, %rsp
    4004cc: mov    %edi, -0x4(%rbp)
    4004cf: cmpl   $0x1, -0x4(%rbp)
    4004d3: ja     4004dc <f+0x18>
    4004d5: mov    $0x1, %eax
    4004da: jmp    40052d <f+0x69>
    4004dc: mov    -0x4(%rbp), %eax
    4004df: and    $0x1, %eax
    4004e2: test   %eax, %eax
    4004e4: jne    4004f5 <f+0x31>
    4004e6: mov    0x200440(%rip), %eax        # 60092c <x.1604>
    4004ec: add    $0x1, %eax
    4004ef: mov    %eax, 0x200437(%rip)        # 60092c <x.1604>
    4004f5: mov    -0x4(%rbp), %eax
    4004f8: and    $0x1, %eax
    4004fb: test   %al, %al
    4004fd: je     40050e <f+0x4a>
    4004ff: mov    0x20042b(%rip), %eax        # 600930 <y.1605>
    400505: add    $0x1, %eax
    400508: mov    %eax, 0x200422(%rip)        # 600930 <y.1605>
    40050e: mov    -0x4(%rbp), %eax
    400511: sub    $0x1, %eax
    400514: mov    %eax, %edi
    400516: callq  4004c4 <f>
    40051b: mov    0x20040f(%rip), %edx        # 600930 <y.1605>
    400521: lea    (%rax,%rdx,1), %edx
    400524: mov    0x200402(%rip), %eax        # 60092c <x.1604>
    40052a: lea    (%rdx,%rax,1), %eax
    40052d: leaveq
    40052e: retq
        \end{minted}
        对应的 C 代码为：
        \begin{minted}[frame=single, fontsize=\small]{c}
    #define N _______________
    #define M _______________
    struct P1 { char c[N]; char *d[N]; char e[N]; } P1;
    struct P2 {int i[M]; char j[M]; short k[M]; } P2;
 
    unsigned int f(unsigned int n) {
        _____ unsigned int x = sizeof(P1);
        _____ unsigned int y = sizeof(P2);
        if (_______________) return 1;
        if (_______________) x++;
        if (_______________) y++;
        return _______________;
    }
        \end{minted}
        \qn 补全上面的空缺。
        \qn 执行 \verb|printf("%x, %x\n", f(2), f(2));| 得到的输出是 \rule{2.5cm}{0.25mm}。
    \end{problems}