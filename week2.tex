\chapter{汇编语言}
    \begin{summary}
        \begin{compactitem}
            \item 知道 x86-64 中指令、程序计数器、寄存器、条件码、内存等概念，记住重要的寄存器名称、含义和使用规范，清楚掌握数据传送指令和操作数的正确用法。
            \item 掌握条件分支、条件传送、各种循环、跳转表的翻译方式，能熟练地在汇编语言中识别控制流结构，快速完成机器码、汇编语言、C 代码的相互转换。
            \item 理解 x86-64 系统栈空间的分布和管理方式，知道过程调用中的重要寄存器和相关保存指令，会复述过程调用的整个过程并绘制栈空间的变化情况。
            \item 知道结构体、联合体在内存中的存储情况，掌握用对齐规则访问结构体和联合体，以及计算其实际大小的方法。会处理复杂的指针和函数指针问题。
        \end{compactitem}
    \end{summary}

    \begin{problems}
        \pro 判断下列 x86-64 ATT 操作数格式是否合法。
            \qn \verb|8(%rax, , 2)|
            \qn \verb|$30(%rax, %rax, 2)|
            \qn \verb|0x30|
            \qn \verb|13(, %rdi, 4)|
            \qn \verb|(%rsi, %rdi, 6)|
            \qn \verb|%ecx|
            \qn \verb|(%ecx)|
            \qn \verb|(%rbp, %rsp)|
        \pro 假设 \verb|%rax|、\verb|%rbx| 的初始值都是 0。根据下列一段汇编代码，写出每执行一步后两个寄存器的值。
        \begin{minted}[frame=single, fontsize=\small]{gas}
    movabsq   $0x0123456789ABCDEF, %rax
    movw      %ax, %bx
    movswq    %bx, %rbx
    movl      %ebx, %eax
    movabsq   $0x123456789ABCDEF, %rax
    cltq
        \end{minted}
        \sol 1 不正确；2 不正确，\verb|$| 只用来表示立即数；3 正确，是内存地址 \verb|0x30|；4 正确；5 不正确，缩放比例只能是 1、2、4、8；6 正确；7 不正确，x86-64 不允许将除了 64 位寄存器以外的寄存器作为寻址模式基地址；8不正确，\verb|%rsp|不能作为操作数！
        \pro 下列操作不等价的是：
        \begin{choices}
            \item \verb|movzbq| 和 \verb|movzbl|
            \item \verb|movzwq| 和 \verb|movzwl|
            \item \verb|movl| 和 \verb|movslq|
            \item \verb|movslq %eax, %rax| 和 \verb|cltq|
        \end{choices}
        \sol C，\verb|movl| 和 \verb|movzlq| 等价。
        \pro 判断下列 x86-64 ATT 数据传送指令是否合法。
            \qn \verb|movl $0x400010, $0x800010|
            \qn \verb|movl $0x400010, 0x800010|
            \qn \verb|movl 0x400010, 0x800010|
            \qn \verb|movq $-4, (%rsp)|
            \qn \verb|movq $0x123456789AB, %rax|
            \qn \verb|movabsq $0x123456789AB, %rdi|
            \qn \verb|movabsq $0x123456789AB, 16(%rcx)|
            \qn \verb|movq 8(%rsp), %rip|
        \pro 在 32 位机器中有如下定义 \texttt{int array[10] = \{0, 1, 2, 3, 4, 5, 6, 7, 8, 9\};}。
        
        某一时刻，\verb|%ecx| 存着第一个元素的地址，\verb|%ebx| 值为 3，那么下列操作中，哪一个将 \verb|array[3]| 移入了 \verb|%eax|？
        \begin{choices}
            \item \verb|leal 12(%ecx), %eax|
            \item \verb|leal (%ecx, %ebx, 4), %eax|
            \item \verb|movl (%ecx, %ebx, 4), %eax|
            \item \verb|movl 8(%ecx, %ebx, 2), %eax|
        \end{choices}
        \pro 下面的汇编代码对应一个 C 函数，其原型为 \verb|long func(long a, long b);|。将其翻译为 C 代码。
        \begin{minted}[frame=single, fontsize=\small]{gas}
    // a in %rdi, b in %rsi
    func:
        movq   %rdi, %rax
        salq   $4, %rax
        subq   %rdi, %rax
        movq   %rax, %rdi
        leaq   0(, %rsi, 8), %rax
        subq   %rsi, %rax
        addq   %rdi, %rax
        ret
        \end{minted}
        \sol 如下所示:
        \begin{minted}[frame=single, fontsize=\small]{c}
    long func(long a, long b) {
        return a * 15 + b * 7;
    }
        \end{minted}
        \pro 指令 \verb|setg %al| 会让寄存器 \verb|%al| 得到：
        \begin{choices}
            \item \verb+~(SF ^ OF) & ~ZF+
            \item \verb+~(SF | OF) & ~ZF+
            \item \verb+~(SF | OF)+
            \item \verb+~(SF ^ OF)+
        \end{choices}
        \pro 下面的汇编代码对应一个 C 函数，其原型为 \verb|long func(long a, long b);|。将其翻译为 C 代码。
        \begin{minted}[frame=single, fontsize=\small]{gas}
    // a in %rdi, b in %rsi
    func: 
        movl    $1, %eax
        jmp     .L2
    .L4: 
        testb   $1, %sil
        je      .L3
        imulq   %rdi, %rax
    .L3: 
        sarq    %rsi
        imulq   %rdi, %rdi
    .L2: 
        testq   %rsi, %rsi
        jg      .L4
        rep ret 
        \end{minted}
        \sol 如下所示（快速幂）：
        \begin{minted}[frame=single, fontsize=\small]{c}
    long func(long a, long b) {
        long ans = 1;
        while (b > 0) {
            if (b & 1)
                ans = ans * a;
            b = b >> 1;
            a = a * a;
        }
        return ans;
    }
        \end{minted}
        \pro 对于下列四个函数，假设 gcc 开了编译优化，判断 gcc 是否会将其编译为条件传送。
        \qn
        \begin{minted}[frame=single, fontsize=\small]{c}
    long f1(long a, long b) { return (++a > --b) ? a : b; }
        \end{minted}
        \qn
        \begin{minted}[frame=single, fontsize=\small]{c}
    long f2(long a, long b) { return (*a > *b) ? --(*a) : (*b)--; }
        \end{minted}
        \qn
        \begin{minted}[frame=single, fontsize=\small]{c}
    long f3(long a, long b) { return a ? *a : (b ? *b : 0); }
        \end{minted}
        \qn
        \begin{minted}[frame=single, fontsize=\small]{c}
    long f4(long a, long b) { return (a > b) ? a++ : ++b; }
        \end{minted}
        \sol 1、4 会被编译成条件传送，注意 \verb|return| 之后 \verb|a, b| 本身的值是没有用的。
        \pro 根据下面的汇编指令补充机器码中缺失的字节。
        \begin{table}[H]
            \centering
            \begin{tabular}{|c|c|}
                \hline
                机器码 & 汇编指令 \\ \hline
                \tt
                \begin{tabular}{l}
                    loop: \\
                    4004d0: 48 89 f8 \\
                    4004d3: eb \verb|_____| \\
                    4004d5: 48 d1 f8 \\
                    4004d8: 48 85 c0 \\
                    4004db: 7f \verb|_____| \\
                    4004dd: f3 c3 
                \end{tabular} &
                \begin{tabular}{l}
                    \\
                    \verb|mov   %rdi, %rax| \\
                    \verb|jmp   4004d8 <loop+0x8>| \\
                    \verb|sar   %rax| \\
                    \verb|test  %rax, %rax| \\
                    \verb|jg    4004d5 <loop+0x5>| \\
                    \verb|repz retq|
                \end{tabular}
                \\ \hline
            \end{tabular}
        \end{table}
        \sol \verb|03; f8|。第五行跳转位置为 \verb|0xf8(-8) + 0x4004dd = 0x4004d5|，注意进行跳转之前，PC 指向该指令的下一条指令。
        \pro 使用 GDB 查看某个可执行文件，发现其一段内存为：
        \begin{minted}[frame=single, fontsize=\small]{text}
    0x400598: 0x0000000000400488 0x0000000000400488
    0x4005a8: 0x000000000040048b 0x0000000000400493
    0x4005b8: 0x000000000040049a 0x0000000000400482
    0x4005c8: 0x000000000040049a 0x0000000000400498
        \end{minted}
        根据以下汇编代码，
        \begin{minted}[frame=single, fontsize=\small]{gas}
    0x400474: cmp   $0x7, %edi
    0x400477: ja    0x40049a
    0x400479: mov   %edi, %edi
    0x40047b: jmpq  *0x400598(, %rdi, 8)
    0x400482: mov   $0x15213, %eax
    0x400487: retq
    0x400488: sub   $0x5, %edx
    0x40048b: lea   0x0(, %rdx, 4), %eax
    0x400492: retq
    0x400493: mov   $0x2, %edx
    0x400498: and   %edx, %esi
    0x40049a: lea   0x4(%rsi), %eax
    0x40049d: retq             
        \end{minted}
        补全主函数的 C 代码。
        \begin{minted}[frame=single, fontsize=\small]{c}
    // a in %rdi, b in %rsi, c in %rdx
    int main(int a, int b, int c) {
        int res = 4;
        switch (a) {
            case 0:
            case 1:
                __________;
            case ___:
                res = __________;
                break;
            case ___:
                res = __________;
                break;
            case 3:
                __________;
            case 7:
                __________;
            default:
                __________;
        }
        return res;
    }
        \end{minted}
        \sol 做法是首先根据跳转表, 确定各标号的起始地址, 然后再作汇编代码的对应. 答案如下所示：
        \begin{minted}[frame=single, fontsize=\small]{c}
    case 0:
    case 1:
        c = c - 5;
    case 2:
        res = 4 * c; // or res *= c
        break;
    case 5:
        res = 86547; // or 0x15213
        break;
    case 3:
        c = 2;
    case 7:
        b = b & c;
    default:
        res += b; // or res = b + 4
        \end{minted}
        \pro 将下列汇编代码翻译成 C 代码。
        \begin{minted}[frame=single, fontsize=\small]{gas}
    func:
        movq   %rsi, %rax
        testq  %rdi, %rdi
        jne    .L7
        rep ret
    .L7:
        subq   $8, %rsp
        imulq  %rdi, %rax
        movq   %rax, %rsi
        subq   $1, %rdi
        call   func
        addq   $8, %rsp
        ret
        \end{minted}
        \begin{minted}[frame=single, fontsize=\small]{c}
    long func(long n, long m) {
        if (__________)
            return __________;
        return func(__________, __________);
    }
        \end{minted}
        \pro 将下列 C 代码翻译为汇编代码。
        \begin{minted}[frame=single, fontsize=\small]{c}
    void callee(long *a, long *b) {
        if (a == b) return;
        *a ^= *b;
        *b ^= *a;
        *a ^= *b;
    }
    void caller(long n, long arr[]) {
        for (long i = 0; i < n/2; i++)
            callee(&arr[i], &arr[n-i]);
    }
        \end{minted}
        汇编代码为:
        \begin{minted}[frame=single, fontsize=\small]{gas}
    callee:
        cmpq   %rsi, %rdi
        je     .L1
        movq   (%rsi), %rax
        xorq   (%rdi), %rax
        movq   ____________
        xorq   (%rsi), %rax
        movq   %rax, (%rsi)
        xorq   %rax, (%rdi)
    .L1:
        rep ret

    caller:
        pushq  %r12
        pushq  %rbp
        pushq  %rbx
        movq   %rdi, %rbp
        movq   %rsi, %r12
        movl   $0, %ebx
        jmp    .L4
    .L5:
        movq   %rbp, %rax
        subq   %rbx, %rax
        ____   (%r12, %rax, ____), %rsi
        ____   (%r12, %rbx, ____), %rdi
        call   callee
        addq   $1, %rbx
    .L4:
        movq   %rbp, %rax
        shrq   $63, %rax
        addq   %rbp, %rax
        sarq   %rax
        cmpq   %rbx, %rax
        jg     .L5
        popq   ____
        popq   ____
        popq   ____
        ret
        \end{minted}
        
        对于上面代码，在 x86-64、操作系统为 Linux 的情况下，假设 main 在 \verb|0x4000ac| 处调用 caller， caller 在 \verb|0x400088| 处调用 callee；调用函数（\verb|call xx|）的代码长度为 5。在 main 即将调用 caller 时，部分寄存器的情况见下表左侧。请在下图右侧画出控制流第一次走 到 \verb|.L1| 时，堆栈的结构。
        \begin{table}[H]
            \centering
            \begin{tabular}{|c|c|c|c|}
                \hline
                寄存器 & 调用前的值 & 地址 & 内容（不确定的空格不用填） \\ \hline
                \verb|%rsp| & \verb|0xffffffffff80| & \verb|0xf...f88~8f| &  \\ \hline
                \verb|%rax| & \verb|0x0| & \verb|0xf...f80~87| &  \\ \hline
                \verb|%rbx| & \verb|0x15| & \verb|0xf...f78~7f| &  \\ \hline
                \verb|%rbp| & \verb|0x18| & \verb|0xf...f70~77| &  \\ \hline
                \verb|%r12| & \verb|0x213| & \verb|0xf...f68~6f| &  \\ \hline
                \verb|%rsi| & \verb|0x0| & \verb|0xf...f60~67| &  \\ \hline
                \verb|%rdi| & \verb|0x0| & \verb|0xf...f58~5f| &  \\ \hline
                &  & \verb|0xf...f50~57| &  \\ \hline
            \end{tabular}
        \end{table}
        \sol 阅读 \verb|callee| 汇编代码可知，首先 \verb|*b| 进入 \verb|%rax|，随后 \verb|%rax| 变为 \verb|*a ^ *b|。根据 C 代码确定下一步要将结果转入 \verb|*a| 中，所以汇编语言代码的空应填写 \verb|%rax, %(rdi)|。\verb|caller| 汇编代码的阅读不需要太仔细(就做题而言)，极易填写。注意这里体现的典型的 \verb|for| 循环结构，快速识别 \verb|%ebx| 为循环变量，\verb|.L4| 后为循环条件检查。后者需要计算 \verb|n / 2|，要留意编译器选择用移位作除法，但是对于负数需要作修正(舍入方式不同)。\verb|sarq| 等移位操作若只有一个操作数，则移位量默认为 1。

        此处栈空间的填写难度不大。首先，\verb|main| 即将发生调用时，\verb|%rsp| 值为 \verb|0xf...f80|，接下来 \verb|call| 后需要在栈中设置返回地址，这个返回地址为 \verb|0x4000ac + 0x5 = 0x4000b1|。所以栈的第三个空填此。注意栈是向下增长的，所以前两个空不确定。接下来 \verb|caller| 要保存 \verb|%r12, %rbp, %rbx| 三个寄存器，因此先后填入 \verb|0x213, 0x18, 0x15|。最后，\verb|callee| 被调用，需要再次填入返回地址 \verb|0x400088 + 0x5 = 0x40008d|。最后一个空显然不确定。
        \pro 在 x86-64、Linux 操作系统下有如下 C 定义：
        \begin{minted}[frame=single, fontsize=\small]{c}
    struct A {
        char CC1[6];
        int II1;
        long LL1;
        char CC2[10];
        long LL2;
        int II2;
    };
        \end{minted}
            \qn \verb|sizeof(A) = |\rule{2.5cm}{0.25mm}。
            \qn 将 \texttt{A} 重排后，令结构体尽可能小，那么得到的新的结构体大小为 \rule{2.5cm}{0.25mm} 字节。
        \pro 在 x86-64、LINUX 操作系统下，考虑如下的 C 定义：
        \begin{minted}[frame=single, fontsize=\small]{c}
    typedef union {
        char c[7];
        short h;
    } union_e;

    typedef struct {
        char d[3];
        union_e u;
        int i;
    } struct_e;

    struct_e s;
        \end{minted}
            \qn \verb|s.u.c| 的首地址相对于 \verb|s| 的首地址的偏移量是 \rule{2.5cm}{0.25mm} 字节。
            \qn \verb|sizeof(union_e) = |\rule{2.5cm}{0.25mm} 字节。
            \qn \verb|s.i| 的首地址相对于 \verb|s| 的首地址的偏移量是 \rule{2.5cm}{0.25mm} 字节。
            \qn \verb|sizeof(struct_e) = |\rule{2.5cm}{0.25mm} 字节。
            \qn 若只将 \verb|i| 的类型改成 \verb|short|，那么 \verb|sizeof(struct_e) = |\rule{2.5cm}{0.25mm} 字节。
            \qn 若只将 \verb|h| 的类型改成 \verb|int|，那么 \verb|sizeof(union_e) = |\rule{2.5cm}{0.25mm} 字节。
            \qn 若将 \verb|i| 的类型改成 \verb|short|、\verb|h| 的类型改成 \verb|int|，则 \verb|sizeof(union_e) = |\rule{2.5cm}{0.25mm} 字节，\verb|sizeof(struct_e) = |\rule{2.5cm}{0.25mm} 字节。
            \qn 若只将 \verb|short h| 的定义删除，那么 (1)\textasciitilde(4) 问的答案分别是 \rule{1cm}{0.25mm}、\rule{1cm}{0.25mm}、\rule{1cm}{0.25mm}、\rule{1cm}{0.25mm} 字节。
        \pro 以下提供了一段代码的 C 语言、汇编语言以及运行到某一时刻栈的情况。
        \begin{minted}[frame=single, fontsize=\small]{gas}
0000000000400596 <func>: 
    400596: sub    $0x28, %rsp
    40059a: mov    %fs:0x28, %rax
    4005a3: mov    %rax, 0x18(%rsp)
    4005a8: xor    %eax, %eax
    4005aa: mov    (%rdi), %rax
    4005ad: mov    0x8(%rdi), %rdx
    4005b1: cmp    %rdx, %rax
    4005b4: jge    _____(1)_____
    4005b6: mov    %rdx, (%rdi)
    4005b9: mov    %rax, 0x8(%rdi)
    4005bd: mov    0x8(%rdi), %rax
    4005c1: test   %rax, %rax
    4005c4: jne    4005cb <func+0x35>
    4005c6: mov    (%rdi), %rax
    4005c9: jmp    _____(2)_____
    4005cb: mov    (%rdi), %rdx
    4005ce: sub    %rax, %rdx
    4005d1: mov    %rdx, (%rsp)
    4005d5: mov    %rax, 0x8(%rsp)
    4005da: mov    _____(3)_____, %rdi
    4005dd: callq  400596 <func>
    4005e2: mov    0x18(%rsp), %rcx
    4005e7: xor    _____(4)_____, %rcx
    4005f0: _____(5)_____    4005f7 <func+0x61>
    4005f2: callq  400460 <__stack_chk_fail@plt>
    4005f7: add    _____(6)_____, %rsp
    4005fb: retq
 
00000000004005fc <main>: 
    4005fc: sub    $0x28, %rsp 
    400600: mov    %fs:0x28, %rax 
    400609: mov    %rax, 0x18(%rsp) 
    40060e: xor    %eax, %eax 
    400610: movq   0x69, (%rsp) 
    400618: movq   0xfc, 0x8(%rsp) 
    400621: mov    %rsp, %rdi 
    400624: callq  400596 <func>
    400629: mov    %rax, %rsi
    40062c: mov    $0x4006e4, %edi
    400631: mov    $0x0, %eax
    400636: callq  400470 <printf@plt>
    40063b: mov    0x18(%rsp), %rdx
    400640: xor    _____(4)_____, %rdx
    400649: _____(5)_____    400650 <main+0x54>
    40064b: callq  400460 <__stack_chk_fail@plt>
    400650: mov    $0x0, %eax
    400655: add    _____(6)_____, %rsp
    400659: retq
        \end{minted}
        C 语言代码：
        \begin{minted}[frame=single, fontsize=\small]{c}
    typedef struct{
        long a;
        long b;
    } pair_type;

    long func(pair_type *p) {
        if (p -> a < p -> b) {
            long temp = p -> a;
            p -> a = p -> b;
            p->b = temp;
        }
        if (_____(7)_____) {
            return p->a;
        }
        pair_type np;
        np.a = _____(8)_____;
        np.b = _____(9)_____;
        return func(&np);
    } 

    int main(int argc, char* argv[]) {
        pair_type np;
        np.a = _____(10)_____;
        np.b = _____(11)_____;
        printf("%ld", func(&np));
    }
        \end{minted}
        堆栈情况如下（从高地址向低地址列举）：
        {\tt \begin{compactenum}
            \item\ 0x0000000000000000
            \item\ 0xc76d5add7bbeaa00 
            \item\ 0x00007fffffffdf60 
            \item\ \verb|__________________|
            \item\ \verb|__________________|
            \item\ 0x0000000000400629 
            \item\ \verb|__________________|
            \item\ \verb|__________________|
            \item\ 0x0000000000000001 
            \item\ 0x0000000000000069 
            \item\ 0x0000000000000093 
            \item\ \verb|__________________|
            \item\ 0x00000000ff000000 
            \item\ \verb|__________________|
            \item\ 0x0000000000000000 
            \item\ \verb|__________________|
            \item\ \verb|__________________|
            \item\ \verb|__________________|
            \item\ 0x0000000000000000 
            \item\ \verb|__________________|
            \item\ \verb|__________________|
            \item\ 0x000000000000002a 
            \item\ 0x000000000000003f 
            \item\ 0x00000000004005e2 
        \end{compactenum}}
        一些可能用到的字符的 ASCII 码如下：
        \begin{table}[H]
            \centering
            \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
                \hline
                换行 & 空格 & \verb|"| & \verb|%| & \verb|(| & \verb|)| & \verb|,| & \verb|0| & \verb|A| & \verb|a| \\ \hline
                \verb|0x0a| & \verb|0x20| & \verb|0x22| & \verb|0x25| & \verb|0x28| & \verb|0x29| & \verb|0x2c| & \verb|0x30| & \verb|0x41| & \verb|0x61| \\ \hline
            \end{tabular}
        \end{table}

        回答下列问题。
            \qn gdb 下使用命令 \verb|x/4b 0x4006e4| 后（即查看 \verb|0x4006e4| 开始的 4 个字节，用 16 进制表示）得到的输出结果是 \rule{2.5cm}{0.25mm}。
            \qn 互相翻译 C 语言代码和汇编代码，补充缺失的空格（标号相同的为同一格）。
            \qn 补充栈的内容。使用16进制，可以不写前导多余的 0；对于给定已知条件后仍无法确定的值，填写“不确定”；已知程序运行过程中寄存器 \verb|%fs| 的值没有改变。
            \qn 程序运行结果是 \rule{2.5cm}{0.25mm}。
        \sol 这是典型的汇编综合题，需要同时结合 C 代码和汇编代码来观察。
        
        第一步先通读 C 代码，确定代码大意，便于在汇编中找一些对应的片段。然后来填写汇编代码。主要难点在厘清 C 语言变量，内存和寄存器的映射关系，确定代码的用途。先看主函数，前三行为金丝雀。接下来，\verb|0x69, 0xfc| 分别进入 \verb|%rsp, %rsp + 8| 对应的内存位置中。根据主函数唯一的 \verb|&np| 取局部变量地址，以及紧接着 \verb|%rsp| 被作为参数传入 \verb|func|，知道这就是 \verb|np| 结构体的初始化工作。所以 C 代码的第 10、11 空分别填写 105、252。

        接着，\verb|func| 的返回值被存入 \verb|%rsi|, 一个立即数（看上去像地址）被存入 \verb|%rdi|，然后调用 \verb|printf| 函数。结合 C 代码知道 \verb|%rdi| 是字符串 \verb|"%ld"|（属于 \verb|char*| 类型）的地址。所以由给出的 ASCII 码表计算得到问答题(1)应填写 \verb|0x25, 0x6c, 0x64, 0x00|。特别留意字符串的最后有一个 \verb|0x00| 表示结尾！主函数的最后几个空是检查金丝雀是否被破坏，易知金丝雀的原值在 \verb|%fs:0x28|，而在栈上对应于地址 \verb|%rsp + 0x18|（这个之后还要用到）。检查金丝雀是否被破坏是容易的，\verb|40063b| 先把后者放到 \verb|%rcx| 中，所以要比较 \verb|%fs:0x28, %rdx|，这就是空(4)的答案。接下来要条件跳转，因为如果条件成立会正常返回，所以空(5)写 \verb|je|。空(6)是函数返回释放栈空间，因为一开始分配了 \verb|0x28| 个字节，所以这个空也要填 \verb|0x28|。

        现在分析 \verb|func| 函数。前三行是金丝雀以及寄存器清零。从地址 \verb|4005aa| 开始分析，首先 \verb|p->a, p->b| 分别进入 \verb|%rax, %rdx| 中。接下来比较 \verb|p->a >= p->b|。结合 C 代码，如果这成立，就不需要经过交换 \verb|p->a, p->b| 的过程。立刻看出，\verb|4005b6, 4005b9| 两行完成了交换工作（没有出现 \verb|temp| 的对应寄存器映射）。由于不确定交换之后 \verb|%rax| 到底对应 \verb|p->a, p->b| 中的哪个，所以其要重新移入 \verb|p->b| 到 \verb|p->a| 中。所以 \verb|4005bd| 就是空(1)的跳转目标。接下来用 \verb|test| 指令判断 \verb|%rax| 是否为 0。注意 C 代码，如果某个条件成立，就要 \verb|return p->a|。因为 \verb|4005cb| 把 \verb|p->a| 放到 \verb|%rax| 中，所以空(2)会跳到函数结尾返回，也就是说跳转目标是 \verb|4005e2|（返回之前要检查金丝雀是否被破坏）。由此也可知只有 \verb|p->b| 为零时才返回，空(7)填写 \verb|p->b == 0|。

        紧接着处理 \verb|func| 的递归调用。结合 C 代码知道要生成新的 \verb|np|，而且 \verb|np.a, np.b| 分别在栈地址的 \verb|%rsp, %rsp + 8| 处。因为这时 \verb|p->a| 在 \verb|%rdx| 中，\verb|p->b| 在 \verb|%rax| 中，所以由 \verb|4005ce, 4005d1| 两行立刻知道(8)、(9)两空分别写 \verb|p->a - p->b, p->b|。

        补全 C 代码后，可以看出这是辗转相除法，输入是 252、105，它们的最大公约数是 21，故问答题的(4)回答 21。

        最后填写栈。对于递归调用，我们应该先正确划分各次调用的栈的边界。第一步，由于主函数和 \verb|func| 一开始都 \verb|subq 0x28, %rsp|，所以栈空间都有 40 字节或 5 个 64 位地址。注意 6 号位置是 \verb|0x400629|，恰好是主函数调用 \verb|func| 的返回地址，所以我们知道 1--5 号位置是主函数的栈帧，6 是从 \verb|func| 返回主函数的返回地址；7--11 是第一次调用 \verb|func| 的栈帧，12 是从第二次递归调用返回第一次调用 \verb|func| 的返回地址，13--17 是第二次调用 \verb|func| 的栈帧，以此类推。所以 12、18 都填 \verb|0x4005e2|（\verb|func| 中递归调用的下一条指令的位置）。
        
        第二步，根据前面的分析，每个栈的栈帧的底部向上数第一个和第二个数都是存储局部变量 \verb|np|（无论是主函数还是 \verb|func|），所以位置 4、5 似乎分别应该写上 \verb|0xfc, 0x69|。但是，注意后面的递归调用中，这两个位置的数会被交换以保证 \verb|p->a >= p->b|！所以这两个空要倒过来，4、5 分别写上 \verb|0x69, 0xfc|。第三步，由前面的分析，金丝雀值一直存在 \verb|%rsp + 0x18|，也就是栈帧自底向上第四个位置，又题目条件说 \verb|%fs| 寄存器没有改变，所以所有的金丝雀值都是 \verb|0xc76d5add7bbeaa00|，这样 8、14、20 都是这个值。

        对于栈的 10、11 号位置，前面的分析知道它们应该是 \verb|252 - 105, 105 = 0x93, 0x69|（顺序未定），而交换后保证上一个要小于下一个，所以 10、11 给出的情况印证我们的分析。同理，16、17 空是 \verb|0x93 - 0x69 = 0x2a, 0x69|，上一个要小于下一个。虽然 22、23 号位置不用填写，但是我们务必注意，栈在这个状态时，刚刚进行下一次递归调用，这两个数还没有被下一次递归调用修改顺序（尽管实际上不需要修改顺序）。

        栈的剩下位置，7、21 都是不确定的，因为只是分配了没有修改过。（注意栈帧开头应该不是旧的帧指针，因为如果要这样需要显式 \verb|push|。）
    \end{problems}

\chapter{汇编语言{---}往年考题}
    \begin{problems}
        \proy{2018} 在 x86-64 下，以下哪个选项的说法是错误的？
        \begin{choices}
            \item \verb|movl| 指令以寄存器作为目的时，会将该寄存器的高位 4 字节设置为 0
            \item \verb|cltq| 指令的作用是将 \verb|%eax| 符号扩展到 \verb|%rax|
            \item \verb|movabsq| 指令只能以寄存器作为目的
            \item \verb|movswq| 指令的作用是将零扩展的字传送到四字节目的
        \end{choices}
        \proy{2018} 下列关于程序控制结构的机器代码实现的说法中，正确的是：
        \begin{choices}
            \item 使用条件跳转语句实现的程序片段比使用条件赋值语句实现的同一程序片段的运行效率高
            \item 使用条件跳转语句实现的程序片段与使用条件赋值语句实现的同一程序片段虽然效率可能不同，但在 C 语言的层面上看总是有着相同的行为
            \item 一些 \verb|switch| 语句不会被 gcc 用跳转表的方式实现
            \item 以上说法都不正确
        \end{choices}
        \proy{2018} 下列关于条件码的叙述中，不正确的是：
        \begin{choices}
            \item 所有算术指令都会改变条件码
            \item 所有比较指令都会改变条件码
            \item 所有与数据传送有关的指令都会改变条件码
            \item 条件码一般不会直接读取，但可以直接修改
        \end{choices}
        \sol 此题有错，A、B 都不准确，有一些 SIMD 指令并不会改变条件码；C 明显是错的；D 基本正确，确实有指令可以直接写条件码。
        \proy{2017} 在下列的 x86-64 汇编代码中，错误的是：
        \begin{choices}
            \item \verb|movq %rax, (%rsp)|
            \item \verb|movl $0xFF, (%ebx)|
            \item \verb|movsbl (%rdi), %eax|
            \item \verb|leaq (%rdx, 1), %rdx|
        \end{choices}
        \sol 此题有错，B、D 都不对，其中 B 不能用 32 位寄存器寻址，D 中少了一个逗号。
        \proy{2017} 在下列关于条件传送的说法中，正确的是：
        \begin{choices}
            \item 条件传送可以用来传送字节、字、双字和四字的数据
            \item C语言中的“\verb|?:|”条件表达式都可以编译成条件传送
            \item 使用条件传送总可以提高代码的执行效率
            \item 条件传送指令不需要用后缀(例如 \verb|b, w, l, q|)来表明操作数的长度
        \end{choices}
        \proy{2017} 在下列指令中，其执行会影响条件码中的 CF 位的是：
        \begin{choices}
            \item \verb|jmp NEXT|
            \item \verb|jc NEXT|
            \item \verb|inc %bx|
            \item \verb|shl $1, %ax|
        \end{choices}
        \proy{2016} 下列关于比较指令 \verb|cmp| 说法中，正确的是：
        \begin{choices}
            \item 专用于有符号数比较
            \item 专用于无符号数比较
            \item 专用于串比较
            \item 不区分比较的对象是有符号数还是无符号数
        \end{choices}
        \proy{2016} 在如下代码段的跳转指令中，目的地址是：
        \begin{minted}[frame=single, fontsize=\small]{gas}
    400020: 74 F0 je   ________
    400022: 5d    pop  %rbp
        \end{minted}
        \begin{choices}
            \item \texttt{400010}
            \item \texttt{400012}
            \item \texttt{400110}
            \item \texttt{400112}
        \end{choices}
        \proy{2016} 对于如下的 C 语言中的条件转移指令，它所对应的汇编代码中至少包含几条条件转移指令：\verb+if (a > 0 && a != 1 || a < 0 && a != -1) b = a;+？
        \begin{choices}
            \item 2 条
            \item 3 条
            \item 4 条
            \item 5 条
        \end{choices}
        \sol B，这个条件相当于 \verb+(a == 0 || a == 1 || a == -1)+。
        \proy{2016} 将 \verb|%ax| 清零，下列指令不能实现该效果的是：
        \begin{choices}
            \item \verb|sub %ax, %ax|
            \item \verb|xor %ax, %ax|
            \item \verb|test %ax, %ax|
            \item \verb|and $0, %ax|
        \end{choices}
        \proy{2016} 在如下 \verb|switch| 语句翻译得到的跳转表中，哪些标号没有出现在分支中？
        \begin{minted}[frame=single, fontsize=\small]{gas}
    addq    $1, %rdi
    cmpq    $8, %rdi
    ja      .L2
    jmp     *.L4(, %rdi, 8)
    .L4:
        .quad .L9
        .quad .L5
        .quad .L6
        .quad. L7
        .quad .L2
        .quad .L7
        .quad .L8
        .quad .L2
        .quad .L5
        \end{minted}
        \begin{choices}
            \item 3, 6
            \item $-1$, 4
            \item 0, 7
            \item 2, 4
        \end{choices}
        \proy{2016} 已知短整型数组 \verb|S| 的起始地址和下标 \verb|i| 分别存放在寄存器 \verb|%rdx| 和 \verb|%rcx|，将 \verb|&S[i]| 存放在寄存器 \verb|%rax| 中所对应的汇编代码是：
        \begin{choices}
            \item \verb|leaq (%rdx, %rcx, 1), %rax|
            \item \verb|movw (%rdx, %rcx, 2), %rax|
            \item \verb|leaq (%rdx, %rcx, 2), %rax|
            \item \verb|movw (%rdx, %rcx, 1), %rax|
        \end{choices}
        \proy{2015} 下列寻址模式中，正确的是：
        \begin{choices}
            \item \verb|(%eax, , 4)|
            \item \verb|(%eax, %esp, 3)|
            \item \verb|123|
            \item \verb|$1(%ebx, %ebp, 1)|
        \end{choices}
        \proy{2015} 假设某条 C 语言 \verb|switch| 语句编译后产生了如下的汇编代码及跳转表：
        \begin{minted}[frame=single, fontsize=\small]{gas}
    movl   8(%ebp), %eax
    subl   $48, %eax
    cmpl   $8, %eax
    ja     .L2
    jmp    *.L7(, %eax, 4)
    .L7:
        .long .L3
        .long .L2
        .long .L2
        .long .L5
        .long .L4
        .long .L5
        .long .L6
        .long .L2
        .long .L3
        \end{minted}
        在源程序中，下面的哪些标号出现过？
        \begin{choices}
            \item \verb|'2', '7'|
            \item \verb|1|
            \item \verb|'3'|
            \item \verb|5|
        \end{choices}
        \sol C，从 \verb|subl| 可看出待比较的数是字符型。
        \proy{2015, 2014} 下列的指令组中，哪一组指令只改变条件码，而不改变寄存器的值？
        \begin{choices}
            \item \verb|CMP, SUB|
            \item \verb|TEST, AND|
            \item \verb|CMP, TEST|
            \item \verb|LEAL, CMP|
        \end{choices}
        \proy{2014} 简单的 \verb|switch| 语句常采用跳转表的方式实现，在 x86-64 系统中，下述最有可能是正确的 \verb|switch| 分支跳转汇编指令的是哪个？
        \begin{choices}
            \item \verb|jmp .L3(, %eax, 4)|
            \item \verb|jmp .L3(, %eax, 8)|
            \item \verb|jmp *.L3(, %eax, 4)|
            \item \verb|jmp *.L3(, %eax, 8)|
        \end{choices}
        \proy{2018} 以下代码的输出结果是
        \begin{minted}[frame=single, fontsize=\small]{c}
    union {
        double d;
        struct {
            int i;
            char c[4];
        } s;
    } u;
    u.d = 1;
    printf("%d\n", u.s.c[2]);
        \end{minted}
        \begin{choices}
            \item 0
            \item $-16$
            \item 240
            \item 191
        \end{choices}
        \proy{2018} 下列关于 C 语言中的结构体（struct）以及联合（union）的说法中，正确的是：
        \begin{choices}
            \item 对于任意 struct，将其成员按照其实际占用内存大小从小到大的顺序进行排列不一定会使之内存占用最小
            \item 对于任意 struct，将其成员按照其实际占用内存大小从小到大的顺序进行排列一定不会使之内存占用最大
            \item 对于任意 union，将其成员按照其实际占用内存大小从小到大的顺序进行排列不一定会使之内存占用最小
            \item 对于任意 union，将其成员按照其实际占用内存大小从小到大的顺序进行排列一定不会使之内存占用最大
        \end{choices}
        \proy{2017} 有如下代码段：
        \begin{minted}[frame=single, fontsize=\small]{c}
    int func(int x, int y);
    int (*p) (int a, int b);
    p = func;
    p(0, 0);
        \end{minted}
        对应的下列 x86-64 过程调用正确的是：
        \begin{choices}
            \item \verb|call *%rax|
            \item \verb|call *(%rax)|
            \item \verb|call (%rax)|
            \item \verb|call func|
        \end{choices}
        \proy{2017} 有定义：\verb|int A[3][2] = {{1,2}，{3,3}，{2,1}};|，则 \verb|A[2]| 是：
        \begin{choices}
            \item \verb|&A + 16|
            \item \verb|A + 16|
            \item \verb|*A + 4|
            \item \verb|*A + 2|
        \end{choices}
        \proy{2015} 已知下面的数据结构，假设在 Linux/IA32 下要求对齐，这个结构的总的大小是多少个字节？如果重新排列其中的字段，最少可以达到多少个字节？
        \begin{minted}[frame=single, fontsize=\small]{c}
    struct {
        char a;
        double *b;
        double c;
        short d;
        long long e;
        short f;
    };
        \end{minted}
        \begin{choices}
            \item 32, 28
            \item 36, 32
            \item 28, 26
            \item 26, 26
        \end{choices}
        \proy{2015} 在“大端法”下，已知如下的 C 语言数据结构：\verb|union { char c[2]; int i; };|。当 \verb|c| 的值为 \verb|0x01, 0x23| 时，\verb|i| 的值为：
        \begin{choices}
            \item \verb|0x0123|
            \item \verb|0x2301|
            \item \verb|0x01230000|
            \item 不确定
        \end{choices}
        \proy{2014} 有如下定义的结构，在 x86-64 下，下述结论中错误的是？
        \begin{minted}[frame=single, fontsize=\small]{c}
    struct {
        char c;
        union {
            char vc;
            double value;
            int vi;
        } u;
        int i;
    } sa;
        \end{minted}
        \begin{choices}
            \item \verb|sizeof(sa) == 24|
            \item \verb|(&sa.i - &sa.u.vi) == 8|
            \item \verb|(&sa.u.vc - &sa.c) == 8|
            \item 优化成员变量的顺序，可以做到 \verb|sizeof(sa) == 16|
        \end{choices}
        \proy{2013} 32 位 x86、Windows 操作系统下定义 struct \verb|S| 包含: \verb|double a, int b, char c|, 请问 \verb|S| 在内存空间中最多和最少分别能占据多少个字节（32 位 Windows 系统按 1、4、8 的原则对齐 \verb|char, int, double|）？
        \begin{choices}
            \item 16, 13
            \item 16, 16
            \item 24, 13
            \item 24, 16
        \end{choices}
    \end{problems}