\chapter{Datalab 回顾}\thispagestyle{empty}
    \begin{summary}
        \begin{compactitem}
            \item 了解位级操作中常见的小模块，包括 de Morgan 律、加法器、减法器、popcount 等，会运用常见策略处理非常规的位运算编程要求，如掩码设计、模拟、分治、位级表示展开等。
            \item 了解各种运算符的优先顺序。知道 ANSI C 与 C99 等标准的不同。初步了解整数在发生强制转换时的基本规则。
            \item 熟练运用 IEEE 754 标准，会使用该标准直接构造浮点数。
            \item 推荐的课外参考书：\textit{Hacker's Delight} 和 \textit{Matters Computational: Ideas, Algorithms, Source Code}，以及一个链接 \url{https://graphics.stanford.edu/~seander/bithacks.html}，里面介绍了一些位运算魔法。Datalab 和往年有一些比较过分的考题大量出自前一本书。因为 datalab 已经 due，故列出来供大家参考。
        \end{compactitem}
    \end{summary}

    我们下面通过几个新例子来回顾 datalab 中用到的重要技巧，供大家回顾、反思和练习，以便于确保从 datalab 中学到了东西。当然，解法不唯一。

    首先是大家已经熟练使用的掩码。它是指一串二进制数字，通过与目标数字的按位操作，达到屏蔽指定位而抽取信息的需求。例如，我们要取得某个二进制数 \texttt{x} 的最高位，可以使用 \verb|(x >> 31) & 1|，这里 \texttt{1} 就是掩码。又如，获得 \texttt{x} 的所有偶数位，可以使用 \verb|x & 0xcccccccc|，这里 \texttt{0xcccccccc} 就是掩码，等等。这段话中我们回顾了 \texttt{allOddBits} 的做法。

    在第一个正式例子中，我们回顾 \texttt{bitNot, bitXor} 两个题的基本思路。
    \begin{example}[de Morgan 律]
        我们知道 \verb+~, &, |+ 可以表达“所有”的逻辑表达式，比方说异或 \verb+x ^ y = (x & ~y) | (~x & y)+。而实际上 \verb+~, |+ 就足以做到这件事，因为我们有 \verb+x & y = ~(~x | ~y)+。这样的情况称为\emph{连接词的完备集}，以后大家还会反复学到。

        当然，其实单纯一个与非或者一个或非也够了。假设\emph{或非} 用 $\downarrow$ 表示（即 $\texttt{x} \downarrow \texttt{y} = \verb+~(x | y)+$），请你完成以下代码：唯一允许的位运算操作符是 $\downarrow$。
        \begin{minted}[frame=single, fontsize=\small, linenos]{c}
    unsigned xor_with_nor(unsigned x, unsigned y) {
        return _________________________; // return x ^ y with only NOR
    }
        \end{minted}
    \end{example}

    在第二个例子中，我们总结和 \texttt{isLessOrEqual, sm2tc, counter1To5} 几个题有关的重要技巧。
    \begin{example}[选择器]
        试用位级运算的技术计算表达式 \texttt{cond ? t : f}。根据注释中的提示尝试补全下面的代码，假设 \texttt{cond} 的输入总是 1 或者 0。
        \begin{minted}[frame=single, fontsize=\small, linenos]{c}
    int conditional(int cond, int t, int f) {
        /* Compute a mask that equals 0x00000000
         * or 0xFFFFFFFF depending on the value of cond */
        int mask = ____________________;
        /* Use the mask to toggle between returning t or returning f */
        return ____________________;
    }
        \end{minted}
        这个例子的意义是，如果你一定想要用 \texttt{if}，可以用这个办法避开 datalab 的限制。更显然地，减法、常数乘法都是事实上可以用的，此外你也可以回顾你在实验题中是怎样表达 \texttt{==} 的。
        \begin{minted}[frame=single, fontsize=\small, linenos]{c}
    int equal(int x, int y) {
        return _________________________; // return x == y
    }

    int minus(int x, int y) {
        return _________________________; // return x - y
    }
        \end{minted}
    \end{example}

    下面的例子则和 \texttt{fullSub, satAdd} 以及 \texttt{trueFiveEighths} 有关。
    \begin{example}[加法器与减法器]
        你可能以前听说过，如果要计算两个无符号数的平均 $\left \lfloor \frac{x+y}{2} \right \rfloor$ 而不发生溢出可以用：\verb|(x & y) + ((x ^ y) >> 1)|。不难看出其原理：\verb|x ^ y| 是半加（不考虑进位）的部分，不会发生溢出，右移即可；另一部分则包括进位，当且仅当两位均为 1 时发生，而如果将这个进位保留在原地，恰好就是除以 2 的效果。这样的思想来自于计算机的加法器。
        \begin{figure}[H]
            \centering
            \tikzstyle{branch}=[fill, shape=circle, minimum size=3pt, inner sep=0pt]
            \begin{tikzpicture}[label distance=2mm]
                \node (x) at (-1,6) {$x$};
                \node (y) at ($(x) + (0,-1.2)$) {$y$};
                \node[not gate US, draw] at ($(x)+(0.5,-0.8)$) (notx) {};
                \node[not gate US, draw] at ($(y)+(0.5,-0.8)$) (noty) {};
                \node[and gate US, draw, rotate=-90, logic gate inputs=nn] at (1,3) (A) {};
                \node[and gate US, draw, rotate=-90, logic gate inputs=nn] at ($(A)+(2,0)$) (B) {};
                \node[and gate US, draw, rotate=-90, logic gate inputs=nn] at ($(B)+(2,0)$) (C) {};
                \node[or gate US, draw, rotate=-90, logic gate inputs=nn] at ($(A)+(1,-1.5)$) (D) {};
                \foreach \i in {x,y} {
                    \path (\i) -- coordinate (punt\i) (\i |- not\i.input);
                    \draw (\i) |- (punt\i) node[branch] {} |- (not\i.input);
                }
                \draw (puntx) -| (C.input 1);
                \draw (punty) -| (C.input 2);
                \draw (puntx) -| (B.input 1);
                \draw (punty) -| (A.input 2);
                \draw (notx) -| (A.input 1);
                \draw (noty) -| (B.input 2);
                \draw (A.output) -- ([yshift=-0.2cm] A.output) -| (D.input 2);
                \draw (B.output) -- ([yshift=-0.2cm] B.output) -| (D.input 1);
                \draw (C) -- ($(C) + (0, -1.8)$) -- node[right] {$C$} ($(C) + (0, -2.5)$);
                \draw (D.output) -- node[right] {$S$} ($(D) + (0, -1)$);
            \end{tikzpicture}
            \caption{半加器的结构，它计算两个一位整数的和 $S$ 及其进位 $C$。可以看出 $S = x \oplus y, C=x \& y$。}
        \end{figure}
        假如我们要运算两个两位数相加，不难看出，只需要将第一位的进位 $C$ 连接到下一位的加法中即可，即下一位是 $x \oplus y \oplus C$，以此类推。

        如果要将加法改成减法，大家都很清楚怎么办，因为 \verb|x - y = x + (~y + 1)|。

        一般来说，有符号数的处理比无符号数稍微需要一些讨论。根据上面的方法，请你尝试给出两个有符号数的平均 $\left \lfloor \frac{x+y}{2} \right \rfloor$ 而不发生溢出的算法；对 $\left \lceil \frac{x+y}{2} \right \rceil$ 做同样的事。
        
        与此相关，请问如何用位运算检查 $x+y$ 是否溢出了？\begin{hint} 检查符号位。 \end{hint}
        \begin{minted}[frame=single, fontsize=\small, linenos]{c}
    int addOK(int x, int y) {
        ________________________________;
        ________________________________;
        // You can add more lines
        return ____; // Determine if we can compute x + y without overflow
    }
        \end{minted}
    \end{example}

    剩下的若干例子中，我们仔细回顾 \texttt{countConsecutive1} 和 \texttt{palindrome} 这两个比较难的问题需要用到的分治技巧。
    \begin{example}[计数]
        让我们来决定一个给定数的二进制表示中，1 的个数是偶数还是奇数；奇数返回 1，否则返回 0。允许使用 datalab 整数部分规定的所有运算符。
        
        这里我们采用\emph{分治}的策略，首先考察比较短的数。例如，当所处理的数只有两位时，采用的代码十分显然：
        \begin{minted}[frame=single, fontsize=\small, linenos]{c}
    int bitParity2bit(int x) {
        int bit1 = 0b01 & x;
        int bit2 = 0b01 & (x >> 1);
        return bit1 ^ bit2;
    }
        \end{minted}
        将异或理解为 $\mathbb F_2$ 上的加法是非常有益的。

        对于四位整数，我们两位两位操作，并让操作的过程某种意义上“并行”进行。首先分别确定 1、2 和 3、4 位的奇偶性，所得结果再设法异或一次。（思考：\texttt{mask2} 可以改成其他数吗？）
        \begin{minted}[frame=single, fontsize=\small, linenos]{c}
    int bitParity4bit(int x) {
        int mask = 0b0101;
        int halfParity = (mask & x) ^ (mask & (x >> 1));
        int mask2 = 0b0011;
        return (mask2 & halfParity) ^ (mask2 & (halfParity >> 2));
    }
        \end{minted}

        现在，请你尝试根据上面的提示，补全下面针对八位整数的算法（要求使用操作符数目不超过 12 个）。
        \begin{minted}[frame=single, fontsize=\small, linenos]{c}
    int bitParity8bit(int x) {
        int mask = ____________________;
        int quarterParity = ____________________;
        int mask2 = ____________________;
        int halfParity = ____________________;
        int mask3 = ____________________;
        return ____________________;
    }
        \end{minted}
        最后，试完成针对十六位或更长整数的算法（注意，根据 datalab 要求，立即数有效长度不能超过 8 位）。
        
        作为模仿练习，请你对问题“决定一个给定数的二进制表示中有多少个 1”做同样的事。
        \begin{minted}[frame=single, fontsize=\small, linenos]{c}
    /* Let's count how many bits are set in a number */
    int bitCount8bit(int x) {
        int mask = ____________________;
        int quarterSum = ____________________;
        int mask2 = ____________________;
        int halfSum = ____________________;
        int mask3 = ____________________;
        return ____________________ + ____________________;
    }
        \end{minted}
    \end{example}

    \begin{example}[模拟操作 2]
        对于一个无符号整数，我们希望将它的位反过来（记为 $\operatorname{rev}(\cdot)$），例如 \texttt{0x01234567} 倒过来就是 \texttt{0xE6A2C480}。

        这个某种意义上是一个广为流传的\sout{面试题}。我们沿用\emph{分治}的思想。假设二进制数 $x$ 有 $2m$ 位 $(\underbracket{b_{2m-1} \dotsm b_m}_{x_h} \underbracket{b_{m-1} \dotsm b_0}_{x_l})_2$，那么显然有
        \[ \operatorname{rev}(x) = \operatorname{rev}(x_l) \operatorname{rev}(x_h). \]
        根据这个思路，请你补全以下代码：
        \begin{minted}[frame=single, fontsize=\small, linenos]{c}
    unsigned reverseBits(unsigned n) {
        n = (n >> 16) | (n << 16);
        n = ((n & __________) >> 8) | ((n & __________) << 8);
        n = ________________________ | _______________________;
        n = __________________________________________________;
        n = __________________________________________________;
        return n;
    }
        \end{minted}

        读过两个分治的操作之后，请思考：给一个整数，如何计算它有多少个前导零？允许的操作符包括所有的位级运算，以及加法和 \texttt{!}。\begin{hint} 二分查找。 \end{hint}
    \end{example}

    \begin{example}[算术运算]
        考虑这样一个问题：对一个无符号整数 $x$, 计算 $x \bmod 5$。除了加法之外不能用其他算术操作。

        方法上这很标准，假设 $x=(b_{31} \dotsm b_1b_0)_2$，通过计算 $2^i \pmod 5$ 的周期，我们知道
        \[ x \equiv \sum_{i=0}^{31} b_i2^i \equiv 1b_0+2b_1+4b_2+3b_3+1b_4 + \dotsb + 3b_{31} \pmod 5. \]
        技术上，对一个四位无符号整数 $(b_3b_2b_1b_0)_2$ 计算 $b_0+2b_1+4b_2+3b_3$ 可以非常直接：比如首先取得各位，然后用左移配合加法计算结果。你也可以思考有什么更省操作符数目的方法。

        注意，当你需要求取 $x \bmod 2^i$ 时，总是可以简单使用 \verb|x & ((1 << i) - 1)|。
    \end{example}